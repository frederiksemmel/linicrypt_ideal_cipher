\chapter{Linicrypt with Ideal Ciphers}

\section{Revisiting Algebraic Representations}
We have defined the algebraic representation for any Linicrypt program.
A question that arises is: Which combination of matrices of the structure $(\M, \C)$
correspond to a Linicrypt program?
To answer this question, we need to define the terminology more carefully.

\begin{defn}
A random oracle constraint of dimension $\base$ with $k$ inputs is a tuple $(t, \v Q, \v a)$ for
$t \in \bin^*$, $\Q \in \F^{k \times \base}$ and $\va \in \F^{1 \times \base}$.
\end{defn}

We call $t$ the nonce and refer to $\Q$ and $\va$ as the query and answer to the random oracle.
Usually we just say constraint when the other variables are clear from the context.
The constraints $(t, \Q, \va)$ encodes a relationship between the base variables $\vbase \in \Base$ of a program.
Namely $\H(t, \Q \vbase) = \va \vbase$.
Because $\H$ is a well-defined function,
and not just any relation,
these requirements extend to the constraints.

\begin{defn}
A set of (random oracle) constraints $\C$ is well-defined if for any pair of constraints 
$c_i, c_j \in \C$ we have $(t_i,\Q_i) = (t_j, \Q_j) \implies \va_i = \va_j$.
\end{defn}

When we use a set of constraints, we will implicitly also require that it is well-defined.
Now we can characterize which sets of constraints correspond to a Linicrypt program.

\begin{defn}[Solvable]
Let $\C$ be a finite set of valid constraints.
$\C$ is (deterministically) solvable if there exists an ordering $(c_1, \dots, c_n)$ of $\C$
and a subspace $\Fix$ of $\Base$
such that for all $i=1, \dots n$:
\begin{enumerate}
\item
    $\spn(\Q_i) \subset \Fix + \spn \big(c_1, \dots, c_{i-1} \big)$
\item
    $\va_i \notin \Fix + \spn \big(c_1, \dots, c_{i-1} \big) + \spn(\Q_i)$
\item
    TODO or this notation
\item
    $\rows(\Q_i) \subset \spn \big(\Fix \cup \rows(c_1) \cup \dots \cup \rows(c_{i-1})\big)$
\item
    $\va_i \notin \spn \big(\Fix \cup \rows(c_1) \cup \dots \cup \rows(c_{i-1}) \cup \rows(\Q_i) \big)$
\end{enumerate}

We call $\Fix$ the solvable space (TODO or free space or fixable space or fixed space) of $\C$
and write $\sol(\C) = \Fix$.
We call $(c_1, \dots, c_n)$ the (solution) ordering of $\C$.
\end{defn}

If we construct the algebraic representation of a Linicrypt program $\P$,
we get a solvable set of constraints.
Indeed, the ordering of the constraints in the definition can be exactly the order of the corresponding queries in the execution of $\P$.
In this case, the solvable space would be the space spanned by the corresponding vectors to the input variables and the randomly sampled variables.

The other direction is also true.

\begin{lemma}[Solvable constraints]
    Let $\C$ be a set of solvable constraints and $k = \dim (\sol (\C))$.
    Let $\out \in \NN$ be arbitrary and $\inp \leq k$.
    Let $\M \in \F^{\out \times \base}$ be an arbitrary output matrix.
    Then there is a basis change $\B \in \F^{\base \times \base}$
    and a Linicrypt program $\P$ taking $\inp$ inputs
    such that $(\M, \C \B^{-1})$ is it's algebraic representation.
\end{lemma}

\begin{proof}
Let $(\vx_1, \dots, \vx_k)$ be a basis for $\sol(\C)$ and let $(c_1, \dots, c_n)$ be the ordering.
The new basis for $\Base$ is $(\vx_1, \dots, \vx_k, \va_1, \dots, \va_n)$.
\[
    \B = 
    \begin{bmatrix}
\vx_1 &
\dots &
\vx_k &
\va_1 &
\dots &
\va_n
    \end{bmatrix}^\top
\]
TODO or
\[
    \B =
    \begin{bmatrix}
\vx_1 \\
\vdots \\
\vx_k \\
\va_1 \\
\vdots \\
\va_n
    \end{bmatrix}
\]

Then we define the constraints $\C'$ via $t_i' = t_i$, $\Q_i' B = \Q_i$ and $\va_i' B = \va_i$.
Note, that, as $\C$ is solvable via the ordering $(c_1, \dots, c_n)$,
these constraints have the form
\begin{align*}
\Q_i' &= \begin{bmatrix} \lambda^i_1 & \cdots & \lambda^i_{i-1} & 0 & 0 & \cdots & 0 \end{bmatrix} \qquad \textrm{for} \quad \lambda^i_j \in \F \\
\va_i' &= \begin{bmatrix} \;0\;\, & \dots & \;\;\;0\;\;\; & 1 & 0 & \dots & 0 \end{bmatrix}
\end{align*}

This is the correct form for an algebraic representation of a program $\P$ taking $\inp \leq k$ inputs,
randomly sampling the next $k - \inp \geq 0$ base variables,
and outputting according to $\M$.
\end{proof}

TODO maybe switch to using input matrices, this would maybe clean things up later
\begin{lemma}[Solvable constraints]
Let $\C$ be a set of solvable constraints and $k = \dim (\sol (\C))$.
Let $\out \in \NN$ be arbitrary and $\inp \leq k$.
Let $\M \in \F^{\out \times \base}$ be arbitrary and $\Inp \in \F^{\inp \times \base}$ such that $\spn(\Inp) \subseteq \sol(\C)$.
Then there is a basis change $\B \in \F^{\base \times \base}$ and a Linicrypt program $\P$
such that $(\Inp \B^{-1}, \M\B^{-1}, \C \B^{-1})$ is it's algebraic representation.
\end{lemma}

\section{Revisiting Collision Structures}
Using this language we can argue about the invertibility of a Linicrypt program and about the possibility to directly calculate second preimages.
Let $\P = (\M, \C)$ be a Linicrypt program.

\begin{lemma}
    $\P$ is invertible if $\rows(\M) \subseteq \sol(\C).$
\end{lemma}

\begin{proof}
TODO
\end{proof}

\begin{lemma}
    $\P$ has a collision structure
    if $\C = \C_{\textrm{fixed}} \sqcup \C_{\textrm{cs}}$ such that
    \begin{equation}
        \sol(\C_\textrm{cs}) \supset \spn\big(\rows(\C_\textrm{fixed}) \cup \rows(\M)\big).
    \end{equation}
\end{lemma}
\begin{proof}
TODO
\end{proof}

Note, that it is crucial that the space on the left is $\supset$ and not only $\supseteq$,
as this gives the extra degree of freedom to find a different preimage.
This is the same role that $w'$ plays in the example from \cite{RMS20}.

This characterization directly includes the case of degeneracy,
because then $\Ccs = \{\}$ and $\sol(\Ccs) = \Base$,
while degeneracy means precisely $\Base \supset \spn(\rows(\C) \cup \rows(\M))$.

The following example was slightly adapted so that it is invertible.

\pcb[valign=c]{$\PE[inv,1](x,y,z)$}{
    w = \H(x) + \H(z) + y \\
    \pcreturn (\H(w) + x, z)
}

\begin{align*}
\M    &= \begin{vmatrix}
            1 & 0 & 0 & 0 & 0 & 1 \\
            0 & 0 & 1 & 0 & 0 & 0 
            \end{vmatrix} \\
\vq_1 &= \begin{vmatrix}1 & 0 & 0 & 0 & 0 & 0\end{vmatrix} \\
\va_1 &= \begin{vmatrix}0 & 0 & 0 & 1 & 0 & 0\end{vmatrix} \\
\vq_2 &= \begin{vmatrix}0 & 0 & 1 & 0 & 0 & 0\end{vmatrix} \\
\va_2 &= \begin{vmatrix}0 & 0 & 0 & 0 & 1 & 0\end{vmatrix} \\
\vq_3 &= \begin{vmatrix}0 & 1 & 0 & 1 & 1 & 0\end{vmatrix} \\
\va_3 &= \begin{vmatrix}0 & 0 & 0 & 0 & 0 & 1\end{vmatrix} \\
\end{align*}

Note, that $(c_3, c_2, c_1)$ is an ordering solving $\C$ and $\rows(M) \subset \sol(\C)$.

TODO finish typing this example

\section{Adapting the Linicrypt model to use block ciphers}

In this chapter we modify the Linicrypt model to make use of the ideal cipher model instead of the random oracle model.
This means that a Linicrypt program gets access to a block cipher $\mathcal{E} = (E, D)$ where $E$ and $D$ are functions $\F \times \F \to \F$
instead of the hash function $\H : \{0,1\}^* \times \F^* \to \F$.
By the definition of a block cipher,
$\E_k := \E(k, \cdot)$ is a permutation of $\F$ for all $k \in \F$ and
$\D_k := \D(k, \cdot)$ is its inverse.
In the ideal cipher model, we assume that the block cipher has no weakness.
This is modeled by choosing each permutation $\E_k$ uniformly at random at the beginning of every security game.

The command $y = \E(k, x)$ in a Linicrypt program has to be treated differently from the command $y = \H(k, x)$ when considering collision resistance,
because an attacker has access to the deterministic Linicrypt program and both directions of the block cipher $\mathcal{E} = (\E, \D)$.
Consider these two programs, $\PH$ in standard Linicrypt and $\PE$ in ideal cipher Linicrypt.

\begin{pchstack}[center,space=2cm]
  \pcbl[valign=c]{$\PH(k, x)$}{
    \pcreturn \H(k,x)
  }
  \pcbl[valign=c]{$\PE(k, x)$}{
    \pcreturn \E(k,x)
  }
\end{pchstack}
While $\PH$ is collision resistant, it is trivial to find second preimages for $\PE$
For any $k' \in \F$ the pair $(k', \D(k', \E(k, x)))$ is a second preimage to $(k,x)$.

This invertibility property of block ciphers has to be taken into account
in both the algebraic representation and the characterization of collision resistance.

\subsection{Algebraic representation for ideal cipher Linicrypt}

Let $\P$ be a ideal cipher Linicrypt program. For each query to $\E$ of the form $y =
\E(k,x)$ we define the \textbf{associated ideal cipher constraint} $(\E, \v k, \v x, \v y)$.
Each query to $\D$ of the form $x = \D(k, y)$, is
associated with the constraint $(\D, \v k, \v y, \v x)$.

As with standard Linicrypt,
we want to exclude programs that make unnecessary queries to the block cipher.
This way the base variables are linearly independent,
except for the dependencies the adversary might introduce by carefully choosing the input.
Hence we assume wlog that no two constraints have the same $(\E, \v k, \v x)$ or $(\D, \v k, \v y)$.

With ideal ciphers there is a second way to make an unnecessary query.
That is by first computing $y = \E(k,x)$ and then $x' = \D(k, y)$.
As $\D_k$ is the inverse of $\E_k$ we have $x = x'$ although $\v x$ and $\v x'$ are linearly independent.


Therefore for all $\v k, \v x, \v x', \v y, \v y' \in \Base$ we can assume there are no two constraints
$(\E, \v k,\v x, \v y)$ and $(\D, \v k, \v y, \v x')$ in $\C$ for $\v x \neq \v x'$.
Neither can there be $(\D, \v k,\v y, \v x)$ and $(\E, \v k, \v x, \v y')$ in $\C$ for $\v y \neq \v y'$.

TODO: Maybe it is simpler with equivalence relation called always colliding queries
\begin{align*}
    (\E, \v k,\v x, \v y) &\sim (\E, \v k, \v x, \v y') \\ 
    (\E, \v k,\v x, \v y) &\sim (\D, \v k, \v y, \v x') \\
    (\D, \v k,\v y, \v x) &\sim (\D, \v k, \v y, \v x') \\
    (\D, \v k,\v y, \v x) &\sim (\E, \v k, \v x, \v y')
\end{align*}
And saying that no two constraints in $\C$ are in the same equivalence class.
This might be cleaner, if the equivalence relation used later to analyze repeated nonces case is defined similarly.

\section{Collision Structure}

To explain the concept of a collision structure, we will make use of an example.
Consider the following Linicrypt program:
\pcb[valign=c]{$\PE[col,1](a,b,c)$}{
    w = E(c, b+c) + a \\
    \pcreturn c + \E(w,b)
}
A second preimage to $(a,b,c)$ can be found by the following procedure:
Choose some $w' \neq w$.
It will turn out, that even choosing $w'$ at random,
one can calculate what the other base variables need to be such that the output stays the same.
As we want $c + \E(w,b) = c' + \E(w', b')$ we can again choose any $b'$ and compute $c'$. 
Finally, we can compute $a'$ from the equation $w' = \E(c', c' + b') + a'$

One can more easily see that such a procedure is possible by looking at the algebraic representation of $\PE[col,1]$.
In order to highlight which are the base variables, we rewrite the program a bit more explicitly.
\pcb[valign=c]{$\PE[col,1](a,b,c)$}{
    k_1 = c \\
    x_1 = b+c \\
    y_1 = \E(k_1, x_1) \\
    k_2 = y_1 + a \\
    x_2 = b \\
    y_2 = \E(k_2, x_2) \\
    \pcreturn c + y_2
}
The base variables are $(a, b, c, y_1, y_2)$ and the algebraic representation is
\[
    \M = \begin{bmatrix} 0, 0, 1, 0, 1 \end{bmatrix} 
        \qquad \C = \{(\E, \v k_1, \v x_1, \v y_1), (\E, \v k_2, \v x_2, \v y_2)\}
\]
where
\begin{align*}
\v k_1 &= \begin{bmatrix} 0, 0, 1, 0, 0 \end{bmatrix} \\
\v x_1 &= \begin{bmatrix} 0, 1, 1, 0, 0 \end{bmatrix} \\
\v y_1 &= \begin{bmatrix} 0, 0, 0, 1, 0 \end{bmatrix} \\
\v k_2 &= \begin{bmatrix} 1, 0, 0, 1, 0 \end{bmatrix} \\
\v x_2 &= \begin{bmatrix} 0, 1, 0, 0, 0 \end{bmatrix} \\
\v y_2 &= \begin{bmatrix} 0, 0, 0, 0, 1 \end{bmatrix}.
\end{align*}

We can formulate the previous attack from in terms of the algebraic representation.
The task is to find a $\v v_\base' = [a', b', c', y_1', y_2'] \neq \v v_\base$ such that:
\begin{align}
\label{constraint_output}
\PE[col,1](a', b', c') = \M \vbase' &= \M \vbase = \PE[col,1](a,b,c) \\
\label{constraint_cipher_1}
y_1' = \vy_i \vbase' &=  \E(\vk_1 \vbase'\,, \; \vx_1 \vbase')\\
\label{constraint_cipher_2}
y_2' = \vy_i \vbase' &=  \E(\vk_2 \vbase'\,, \; \vx_2 \vbase')
\end{align}

We can fulfill these requirements step by step.
First, we constrain $\vbase'$ by requiring 
\[
    \M \vbase' = \M \vbase.
\]
This reduces the dimension of the space of possible solutions for $\vbase'$ to 4,
as $\M \vbase$ is in the range of $\M$ by definition.
Now note, that neither $\vk_2$ nor $\vx_2$ are in the span of $\rows(\M)$.
Therefore we can choose $k_2'$ and $x_2'$ at random such that $(k_2', x_2') \neq (k_2, x_2)$,
and constrain $\vbase'$ by requiring
\[
    \vk_2 \vbase' = k_2' \quad \textrm{and} \quad \vx_2 \vbase' = x_2'.
\]
Now we can compute $y_2' = \E(k_2', x_2')$ and add constraint \eqref{constraint_cipher_2}.
This constraint is compatible with the previous constraints because $\vy_2$ is not in the span of
$\rows(\M) \cup \{\vk_2, \vx_2\}$.
The dimension of the subspace of solutions is now 1, as we have added 4 one-dimensional constraints.

Now one only needs to fulfill constraint \eqref{constraint_cipher_1}.
As $\vk_1$ and $\vx_1$ are in the span of
$\rows(\M) \cup \{\vk_2, \vx_2, \vy_2\}$ the intermediate variables $k_1'$ and $x_1'$ are uniquely determined.
E.g. $\vk_1 = \M - \vy_2$ and therefore $k_1' = \PE[col,1](a,b,c) - y_2'$.

Finally, note that 
$\vy_1 \notin \spn\big( \rows(\M) \cup \{ \vk_2, \vx_2, \vy_2 \} \cup \{ \vk_1, \vx_1 \} \big)$.
Therefore, adding the constraint
\[
    \vy_1 \vbase' = y_1' = \E(k_1', x_1')
\]
reduces the solution space of possible $\vbase'$ to a single point in $\Base$.
We know that $\vbase' \neq \vbase$ because $(k_2, x_2') \neq (k_2, x_2)$.
The only way to produce different intermediate variables in a deterministic program is to choose different input,
hence $(a',b',c') \neq (a,b,c)$.

This example would have worked exactly the same if we replaced $\E$ with $\H$.
What follows is an example where the invertibility property of $\E_k$ plays a role.

\begin{pchstack}[center, space=2cm]
    \pcbl[valign=c]{$\PE[col,2](a,b,c)$}{
        k_1 = c \\
        x_1 = b \\
        y_1 = \E(k_1, x_1) \\
        k_2 = a \\
        x_2 = y_1 \\
        y_2 = \E(k_2, x_2) \\
        \pcreturn y_1 + y_2
    }
    \pseudocode[valign=c]{
        \M    = \begin{bmatrix}0,0,0,1,1\end{bmatrix} \\
        \vk_1 = \begin{bmatrix}0,0,1,0,0\end{bmatrix} \\
        \vx_1 = \begin{bmatrix}0,1,0,0,0\end{bmatrix} \\
        \vy_1 = \begin{bmatrix}0,0,0,1,0\end{bmatrix} \\
        \vk_2 = \begin{bmatrix}1,0,0,0,0\end{bmatrix} \\
        \vx_2 = \begin{bmatrix}0,0,0,1,0\end{bmatrix} \\
        \vy_2 = \begin{bmatrix}0,0,0,0,1\end{bmatrix} 
    }
\end{pchstack}
For this program there is a similar procedure to find second preimages.
As before, the first constraint is $\M $
In this case we can fix $\vk_2 \vbase' = k_2' = k_2$, $\vx_2 \vbase' = x_2' = x_2$ and $\vy_2 \vbase' = y_2' = y_2$.
Therefore condition \eqref{constraint_cipher_2} is fulfilled trivially.
After adding these 4 constraints the solutions space is still 1-dimensional.
Note, that $\vy_1 = \vx_2$ and it is therefore already fixed at this point,
hence to fulfill \eqref{constraint_cipher_1} we have to make use of the invertibility property of $\E_k$.
Because
\begin{align*}
    \vy_1 \vbase' &= \E(\vk_1 \vbase', \vx_1 \vbase') \\
    \iff \vx_1 \vbase' &= \D(\vk_1 \vbase', \vy_1 \vbase'),
\end{align*}
we can choose a random $k_1' \neq k_1$ and compute $x_1' = \D(k_1', y_1')$ in order to fulfill (3.1).
With this fifth constraint we have found a single $\vbase' \neq \vbase$.

We want to briefly summarize the conditions for this kind of second preimage attack.
Let $\P'$ denote the execution of 
\begin{itemize}
\item
    Some ideal cipher constraints are fulfilled by setting the intermediate variables in $\P(a',b',c')$ to the same value as in $\P(a,b,c)$ 
\item
    There is some constraint for which either the input or the output is undetermined by the previously fixed intermediate variables
\item
    For this constraint and all following constraint one can iteratively call the ideal cipher $\BC$ to set the intermediate variables such that the constraints are fulfilled.
    This is only possible, if the either the output or the input is undetermined by previously fixed variables.
\end{itemize}


\begin{defn}[Collision structure]
Let $\P = (\M, \C)$ be a Linicrypt program with $|\C| = n$.
A \textbf{collision structure} for $\P$ is an index $1 \leq i^* \leq n$, an ordering $(c_1, \dots, c_n)$ of $\C$ for $c_i = (Op_i, \v k_i, \v q_i,\v a_i)$
and a tuple $(dir_{i^*}, \dots, dir_n)$ for $dir_i \in \{\For, \Back\}$,
such that the following two conditions hold:
\begin{enumerate}
\item 
Let $\mathcal{F}_\is = \{
    \v k_1, \dots, \v k_{i^* -1},
    \v q_1, \dots, \v q_{i^* -1},
    \v a_1, \dots, \v a_{i^* -1}
    \}$. One of the following is true:
        \begin{enumerate}
    \item $dir_\is = \For \quad$ and 
        $\quad
            \spn\big(\{ \v k_{i^*}, \v q_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F}_\is \cup \rows\left(\M\right) \big)
        $
    \item $dir_\is = \Back \quad$ and 
        $\quad
            \spn\big(\{ \v k_{i^*}, \v a_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F}_\is \cup \rows\left(\M\right) \big)
        $
\end{enumerate}
\item For all $j \geq i^*$ let $\mathcal{F}_j = \{
    \v k_1, \dots, \v k_{j -1},
    \v q_1, \dots, \v q_{j -1},
    \v a_1, \dots, \v a_{j -1}
    \}$. One of the following is true:
\begin{enumerate}
    \item $dir_j = \For \quad$ and 
        $\quad
        \v a_j \notin \spn\big(
        \mathcal{F}_j
        \cup \{ \v k_j, \v q_j\}
        \cup \rows\left(\M\right)
        \big)
        $
    \item $dir_j = \Back \quad$ and 
        $\quad
        \v q_j \notin \spn\big(
        \mathcal{F}_j
        \cup \{ \v k_j, \v a_j\}
        \cup \rows\left(\M\right)
        \big)
        $
\end{enumerate}
\end{enumerate}
\end{defn}

TODO: Remove this wordy definition.
All the info from here should be integrated into the example

\begin{defn}[Collision structure]
Let $\P = (\M, \C)$ be a Linicrypt program with $|\C| = n$.
A \textbf{collision structure} for $\P$ is an index $1 \leq i^* \leq n$, an ordering $(c_1, \dots, c_n)$ of $\C$ for $c_i = (Op_i, \v k_i, \v q_i,\v a_i)$
and a tuple $(dir_{i^*}, \dots, dir_n)$ for $dir_i \in \{\For, \Back\}$,
such that:
\begin{enumerate}
\item The $i^*$'th constraint is unconstrained by the output of $\P$ and previous fixed constraints.
Let $\mathcal{F} = \{
    \v k_1, \dots, \v k_{i^* -1},
    \v q_1, \dots, \v q_{i^* -1},
    \v a_1, \dots, \v a_{i^* -1}
    \}$
denote the vectors fixed by previous constraints in the ordering.
\begin{enumerate}
    \item if $dir_\is = \For$, the input of the query associated to $c_\is$ is unconstrained:
        \[
            \spn\big(\{ \v k_{i^*}, \v q_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F} \cup \rows\left(\M\right) \big)
        \]
    \item if $dir_\is = \Back$, the output of the query associated to $c_\is$ is unconstrained:
        \[
            \spn\big(\{ \v k_{i^*}, \v a_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F} \cup \rows\left(\M\right) \big)
        \]
\end{enumerate}
\item For all $j \geq i^*$ the constraint $c_j$ does not contradict previous constraints.
Let $\mathcal{F} = \{
    \v k_1, \dots, \v k_{j -1},
    \v q_1, \dots, \v q_{j -1},
    \v a_1, \dots, \v a_{j -1}
    \}$
denote the vectors fixed by previous constraints in the ordering.
\begin{enumerate}
    \item if $dir_j = \For$
        \[
        \v a_j \notin \spn\big( \{
        \v k_1, \dots, \v k_{j -1},
        \v q_1, \dots, \v q_{j -1},
        \v a_1, \dots, \v a_{j -1},
        \} 
        \cup \{ \v k_j, \v q_j\}
        \cup \rows\left(\M\right)
        \big)
        \]
    \item if $dir_j = \Back$
        \[
        \v q_j \notin \spn\big( \{
        \v k_1, \dots, \v k_{j -1},
        \v q_1, \dots, \v q_{j -1},
        \v a_1, \dots, \v a_{j -1},
        \} 
        \cup \{ \v k_j, \v a_j\}
        \cup \rows\left(\M\right)
        \big)
        \]
\end{enumerate}
\end{enumerate}
\end{defn}

\begin{lemma}[Collision structure gives second preimages]
    If collision structure blabla exists for $\P = (\M, \C)$ then blabla with probability 1.
\end{lemma}

\pcb[mode=text]{$\mathsf{FindSecondPreimage}\Big(\Big)$}{
Compute $\vbase$ by executing $\PE(\vx)$  \\
... very similar
}
