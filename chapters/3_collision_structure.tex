\chapter{Linicrypt with Ideal Ciphers}

\section{Revisiting Algebraic Representations}
\label{revisiting_algebraic_representations}
In the previous section we have defined the algebraic representation for a Linicrypt program.
It consists of the input matrix $\Inp \in \F^{k \times \base}$,
the output matrix $\O \in \F^{l \times \base}$
and the set of constraints $\C = \{ (t_i, \Q_i, \va_i) \mid i = 1, \dots, n \}$,
with $\Q_i \in \F^{m_i \times \base}$ and $\va_i \in \F^{1 \times \base}$.
These matrices are such that,
if one constrains $\vbase \in \Fsp$ with $\I\vbase = \m{i_1 & \cdots & i_k}^\top$ for some arbitrary input,
the program can compute the rest of the base variables and output $\O \vbase = \m{o_1 & \cdots & o_l}^\top$.
To simplify the notation we will also write $\vec i k$ for the column vector $\m{i_1 & \cdots & i_k}^\top$.

Our goal for this section is to find a better understanding of collision structures.
The algebraic representation suggest
that the input and output matrix play similar roles:
They are linear constraints for the base variables. 
Therefore, collision resistance should be expressible in terms of the ability to solve the constraints $\C$ while setting $\O\vbase$ to some value.  
This idea will be formalized in this section.
A question that arises is:
Which combination of matrices with the structure described above correspond in essence to a Linicrypt program?
To answer this question,
we need to define what a random oracle constraint is for arbitrary vectors.

\begin{defn}[Random oracle constraint]
A \textbf{random oracle constraint} of dimension $\base$ taking $m$ inputs is a tuple $(t, \v Q, \v a)$ for
$t \in \bin^*$, $\Q \in \F^{m \times \base}$ and $\va \in \F^{1 \times \base}$.
\end{defn}

This definition is a generalization of the definition in the preliminaries.
When constructing the algebraic representation for a Linicrypt program,
we always have the special case that $\va = \m{0&\cdots&0&1&0&\cdots&0}$.
If the nonce is the empty string, then we just write $(\Q, \va)$ instead of $(t, \Q, \va)$.
We call $t$ the nonce and refer to $\Q$ as the query matrix and to $\va$ as answer matrix.
Usually we just say ``a constraint" when the other variables are clear from the context.

The constraint $(t, \Q, \va)$ encodes the relationship via the random oracle between the base variables in a program.
This semantic meaning of the constraints is encoded in the following definition.
\begin{defn}[Solution of constraints]
    Let $\C$ be a set of constraints of dimension $\base$.
    We say a vector $\vv \in \Base$ \textbf{solves} $\C$ if
    $\va \vv = \H(t, \Q \vv)$ for all $(t, \Q, \va) \in \C$.
    Such a $\vv$ is also called a \textbf{solution} of $\C$.
    The set of all solutions to $\C$ is called $\sol(\C)$.
\end{defn}

Because $\H$ is a well-defined function,
and not just any relation,
these requirements extend to the constraints.

\begin{defn}[Well-defined]
A set of (random oracle) constraints $\C$ is \textbf{well-defined} if for any pair of constraints 
$c, c' \in \C$ we have $(t,\Q) = (t', \Q') \implies \va = \va'$.
\end{defn}

When we use a set of constraints, we will implicitly also require that it is well-defined.
Highlighting the function like properties of a constraint $(t, \Q, \va)$,
we will also use the shorthand $(t,\Q) \mapsto \va$, or $\Q \mapsto \va$ if $t$ in case t is an empty string.
This notation was introduced in \cite{CSF:HolRosRoy22}.

We want to analyze which sets of constraints have solutions and how these solutions can be computed.
First, every Linicrypt program is a method to solve the constraints $\C$ from it's algebraic representation.
If we run a program $\P$ on some input $(\dts i k)$,
it will query the random oracle
and solve each random oracle constraint one by one in the order of the corresponding queries in $\P$.
Let us call the resulting vector containing the values of the base variables in this execution $\vv \in \Fsp$.
Then it is a solution of $\C$ satisfying $\I\vv = (\dts i k)$.

If a set of constraints is well-defined, it might still not  correspond to a valid Linicrypt program.
Consider the set
\[
\C = \left\{ \m{1&0} \mapsto \m{0&1}, \m{0&1} \mapsto \m{1&0}\right\}.
\]
Although it is well-defined,
it would correspond to the two calls to the random oracle that are not compatible with the Linicrypt model.
Specifically, such constraints would correspond to a program which contains the commands
$y = H(x)$ and $x = H(y)$, where $x,y$ are intermediate variables.
There is no order in which these two calls can be executed without doing a reassignment,
which does not exist in Linicrypt.
Still, this set of constraints might have solutions.
For every $x \in \F$ with the property that $x = \H(\H(x))$ the vector $(x, \H(x))$ is a solution of $\C$.
In other words,
the set $\C$ expresses a condition on the base variables which cannot be represented by a Linicrypt program.

In order to characterize which constraints can be solved by a Linicrypt program,
we need to consider the concept of basis change as it was introduced in \cite{C:CarRos16}.

\begin{defn}[Basis change]
    Let $\v B$ be any matrix in $\F^{\base \times \base'}$
    and $\P = (\Inp, \O, \C)$ be a Linicrypt program.
    We define 
    \[
        \C \B \coloneqq \big\{ (t, \Q \B, \va \B) \mid (t, \Q, \va) \in \C \big\}.
    \]
    If $\B$ is invertible,
    we say $\P\B \coloneqq (\Inp \B, \O \B, \C \B)$ is a \textbf{pseudo algebraic representation} of $\P$.
\end{defn}

The concept of basis change plays well with the definition of the set of solutions for some constraints.
Let $\C$ a any set of constraints and $\B$ be a basis change matrix.
Note the following equivalences due to associativity of the matrix product:
\begin{align*}
&\parbox{30pt}{\phantom{$\iff$}} \vv \textrm{ solves } \C\B \\
&\parbox{30pt}{$\iff$} \H(t, \Q \B \vv) = \va \B \vv \quad \textrm{for all} \quad (t, \Q, \va) \in \C \\
&\parbox{30pt}{$\iff$} \B \vv \textrm{ solves } \C
\end{align*}

This implies that $\B: \sol(\C\B) \to \sol(\C)$ is a well-defined bijection.

We restrict our goal to characterizing which matrices $\I$ and $\O$ and constraints $\C$ are pseudo algebraic representations of some program $\P$. 
This is interesting because it enables us to choose an arbitrary input matrix for a given set $\C$ and check whether there exists a Linicrypt program which computes solutions to $\C$.
The degeneracy and collision structure attack described in \cite{TCC:McQSwoRos19} are both attacks that can be performed as Linicrypt programs.

First, we describe the form $(\I, \O, \C)$ need to have such that they are the algebraic representation of a Linicrypt program.
\begin{lemma}
    Let $\C$ be a finite well-defined set constraints of dimension $\base$ with $|\C| = n$,
    let $\I = \m{\Id_k & 0} \in \F^{k\times\base}$ for $k = \base - n$
    and let $\O \in \F^{l \times \base}$ for some $l \in \NN$.
       
    $(\I, \O, \C)$ is the algebraic representation of a Linicrypt program $\P$
    if there exists an ordering $(c_1, \dots, c_n)$ of $\C$
    such that for all $i=1, \dots, n$:
%     \begin{enumerate}
%     \item
%     $
% \parbox{14pt}{$\Q_i$} = \begin{bmatrix} \parbox{12pt}{$\lambda^i_1$} & \cdots & \parbox{32pt}{$\lambda^i_{k+i-1}$} & 0 & 0 & \cdots & 0 \end{bmatrix} \qquad \textrm{for} \quad \lambda^i_j \in \F^{m_i}
%     $
%     \item
%     $
% \parbox{14pt}{$\va_i$} = \begin{bmatrix} \parbox{12pt}{$0$} & \cdots & \parbox{32pt}{$0$} & 1 & 0 & \cdots & 0 \end{bmatrix}
%     $
%     \end{enumerate}
    \begin{enumerate}
    \item
    $\rows(\Q_i) \in \spn(\dts \ve {k+i-1})$
    \item
    $\va_i = \ve_{k+i}$
    \end{enumerate}
\end{lemma}

\begin{proof}
    This is only a sketch proof.
    In order to formalize it one first has to formalize the Linicrypt model as is done in \cite{C:CarRos16}.

    Assume there is such an ordering as in the Lemma.
    We will construct the program $\P$.
    First $\P$ will store it's $k$ inputs into intermediate variables,
    thus the input matrix is $\I = \m{\Id_k & 0}$.
    Then each of the random oracle constraints is converted into Linicrypt commands of the form
    $v_{k+i} = H(\dts q {k+i-1})$.
    Condition 1. from the Lemma ensures that $\dts q {k+i-1}$ are linear combinations only of previously defined intermediate variables.  
    Condition 2. from the Lemma garantuees that the variable $v_{k+i}$ hasn't been used previously,
    so the command is a valid Linicrypt commmand.
    
    Finally, because $k=\base - n$, we have instantiated all base variables and we can therefore output according to $\O$.
\end{proof}

We now generalizing the condition from the Lemma in order to make it independent of the chosen basis of $\Fsp$.
This leads to the characterization of pseudo algebraic representations.

\begin{defn}[Deterministically Solvable]
\label{def_det_solvable}
    Let $\C$ be a finite well-defined set constraints of dimension $\base$,
    and let $\I \in \F^{k \times \base}$ for some $k \in \NN$.
    $\C$ is \textbf{deterministically solvable} fixing $\I$
    if there exists an ordering $(c_1, \dots, c_n)$ of $\C$
    such that for all $i=1, \dots, n$:
    \begin{enumerate}
    \item
        \label{solvable1}
        $\rows(\Q_i) \subset \spn \big(\rows(\I) \cup \{\va_1, \dots, \va_{i-1}\}\big)$
    \item
        \label{solvable2}
        $\va_i \notin \spn \big(\rows(\I) \cup \{\va_1, \dots, \va_{i-1}\} \cup \rows(\Q_i) \big)$
    \end{enumerate}
    Additionally we require that $\rows(\I) \cup \{\va_1, \dots, \va_n\}$ form a basis of $\F^{1\times\base}$.
    We call $(c_1, \dots, c_n)$ a solution ordering of $\C$ fixing $\I$ (or fixing $\rows(\I)$).
\end{defn}

This is similar to the definition of collision structure in \cite{TCC:McQSwoRos19}.
Indeed, we will use it to combine the collision structure and degeneracy attack from that work.

Intuitively, $\C$ being deterministically solvable fixing $\I$ means the following.
We can constrain $\vv \in \Fsp$ by $\Inp \vv = (i_1, \dots, i_k)$ for an arbitrary input $i_1, \dots, i_k \in \F$,
and then compute each oracle query (Condition \ref{solvable1} in Definition \ref{def_det_solvable}) one by one,
without creating a contradiction (Condition \ref{solvable2} in Definition \ref{def_det_solvable}).


If we construct the algebraic representation $(\I, \O, \C)$ of a deterministic Linicrypt program $\P$,
then $\C$ is a deterministically solvable set of constraints fixing $\I$.
Indeed, the solution ordering of $\C$ fixing $\I$
can be exactly the order of the corresponding queries in the execution of $\P$.

\begin{lemma}
    Let $(\I, \O, \C)$ be the algebraic representation of a deterministic Linicrypt program $\P$ taking $k$ inputs.
    Then $\C$ is deterministically solvable fixing $\I$.
\end{lemma}

\begin{proof}
    Consider a constraint $(t, \Q, \va)$ in $\C$.
    By definition, for some $i$,
    $\va$ is the $i$'th canonical basis row vector,
    and $\Q$ only has only zeros in the columns to the right of column $i$.
    We can sort $\C = \{\dts c n\}$, such that the $\va$'s are sorted.
    Indeed, this is the same order as the associated oracle calls in the execution of $\P$.
    
    Clearly condition \ref{solvable2} from Definition $\ref{def_det_solvable}$ is then fulfilled.
    Because $\P$ is deterministic, 
    the queries to the oracle are linear combinations of input variables and results of previous queries.
    Therefore condition \ref{solvable1} must be fulfilled.
    Finally, as $\P$ contains no sampling operation, we know $\base = k + n$.
    The associated vectors $\rows(I) = \dts \vi k$ to the input variables are linearly independent,
    hence it follows that $\{ \dts \vi k, \dts \va n \}$ is a basis of $\F^{1\times\base}$. 
\end{proof}

The following Lemma shows that the reversed direction also works,
meaning that we can recover a deterministic Linicrypt program from deterministically solvable constraints by applying a basis change.
This equivalence up to basis change is not a problem, 
because any security characterization we make based off of the algebraic representation will always be invariant under basis change.

\begin{lemma}
\label{det_solvable_lemma}
    Let $\C$ be a set of deterministically solvable constraints fixing $\Inp \in \F^{k \times \base}$ for some $k \in \NN$.
    Let $\O \in \F^{\out \times \base}$ be an arbitrary output matrix for some $\out \in \NN$.
    Then there is a basis change $\B \in \F^{\base \times \base}$
    and a Linicrypt program $\P$,
    such that $(\Inp \B, \O \B, \C \B)$ is its algebraic representation.
\end{lemma}

\begin{proof}
Let $(c_1, \dots, c_n)$ be the solution ordering of $\C$ fixing $\I = \mtdts \vi k$.
We choose the new basis for $\Frowsp$ as $(\dts \vi k, \dts \va n)$, hence the basis change matrix is defined by
% \[
%     \B^{-1} = 
%     \begin{bmatrix}
% \vi_1^\top &
% \cdots &
% \vi_k^\top &
% \va_1^\top &
% \cdots &
% \va_n^\top
%     \end{bmatrix}^\top.
% \]
\[
    \B^{-1} = 
    \begin{bmatrix}
\vi_1 \\
\vdots \\
\vi_k \\
\va_1 \\
\vdots \\
\va_n
    \end{bmatrix}.
\]

In the following we denote by $\v e_i$ the $i$'th canonical row vector in $\Fsp$.
By definition of $\B$ we have for $i=1, \dots, n$
% TODO this is not compact enough, for its importance
\begin{equation*}
\I = \begin{bmatrix}
    \v e_1 \\
    \vdots \\
    \v e_k
\end{bmatrix} \B^{-1}
\qquad \textrm{and} \qquad
\va_i = \v e_{k+i} \B^{-1},
\end{equation*}
which is equivalent to
\begin{equation*}
\I \B = \begin{bmatrix}
    \v e_1 \\
    \vdots \\
    \v e_k
\end{bmatrix}
\qquad \textrm{and} \qquad
\va_i \B = \v e_{k+i}.
\end{equation*}

Additionally, as $\C$ is solvable via the ordering $(c_1, \dots, c_n)$,
we know that 
\[
\rows(\Q_i \B) \subset \spn(\vi_1 \B, \dots, \vi_k \B, \va_1 \B, \dots, \va_{i-1} \B) = \spn( \ve_1, \dots, \ve_{k+i-1} )
\]

This shows that $(\I\B, \O\B, \C\B)$ is a straight-line algebraic representation,
therefore we obtain the corresponding program $\P$ from the statement.
\end{proof}

In order to abstract the questions about deterministic Linicrypt programs to the level of the algebraic representation,
we need the following Lemma and Corollary.

Let $\P = (\I, \O, \C)$ be a deterministic Linicrypt program taking $k$ inputs and returning $l$ outputs.
First we note that one can see a deterministic Linicrypt program as a function from its input space to its output space.
We associate to $\P$ the function $f_\P: \F^k \to \F^l$ which maps $(\dts i k)$ onto the output of $\P(\dts i k)$.

\begin{lemma}
\label{solution_space_bijection}
    Let $\C$ be deterministically solvable fixing some $\I$.
    If we view $\I$ as a function $\Fsp \to \F^k$,
    then $\I|_{\sol(\C)}$ is a bijection.
\end{lemma}

\begin{proof}
    If we set $\O = \Id_\base$
    then we can apply Lemma \ref{det_solvable_lemma} to get a deterministic program $\P$ and basis change $\B$. 
    The associated function $f_{\P}: \F^k \to \F^\base$ is injective,
    as the input variables are base variables.
    Note, that by definition of $\P$ we know that $f_{\P}$ actually maps to $\sol(\C\B)$.
    Hence $|\F^k| \leq |\sol(\C\B)|$.
    Because $\vv$ solves $\C\B$ is equivalent to $\B\vv$ solves $\C$,
    we also know that $|\sol(\C\B)| = |\sol(\C)|$. 
    Putting this together we find that $|\F^k| \leq |\sol(\C)|$.

    Now we will show that the input matrix $\I: \Fsp \to \F^k$ is injective
    when restricted to $\sol(\C)$.
    This would then complete the proof, because $\F^k$ is a finite set.
    
    Assume we have $\vv, \vv' \in \sol(\C)$ with $\I\vv = \I\vv'$.
    Also assume that we $\C$ is deterministically solvable fixing $\I$,
    so we have an ordering $(\dts c n)$ of $\C$.
    We will inductively prove that $\va_i \vv = \va_i \vv'$ for all $i = 1, \dots, n$.

    Assume this is true for all $ j \leq i$.
    Because of the solution ordering of $\C$ we know that
    $\rows(\Q_{i+1}) \in \spn\{ \rows(\I) \cup \{\dts \va {i}\}\}$. 
    This means there is a $\v \lambda$ such that $\Q_{i+1} = \v \lambda \m{\I^\top & \va_1^\top & \cdots & \va_n^\top}^\top =: \lambda \v A_i$.
    Therefore we have $\Q_{i+1} \vv' = \vl \v A_i \vv' = \vl \v A_i \vv = \Q_{i+1} \vv$.
    Because $\vv$ and $\vv'$ are solutions to $\C$ we know that
    $\va_{i+1}\vv' = \H(\Q_{i+1}\vv') = \H(\Q_{i+1}\vv) = \va_{i+1}\vv$.

    Because $\rows(\I) \cup \{\va_1, \dots, \va_n\}$ is a basis, 
    the matrix 
    \[
    \B = \m{\I \\ \vdts \va n}
    \]
    is invertible.
    Using the assumptions and the results from the induction we have shown that $\B \vv' = \B \vv$ and
    therefore $\vv' = \vv$.
    This shows that $\I|_{\sol(\C)}$ is injective and that $|\F^k| \geq |\sol(\C)|$.
    By the previous argument this proves that $|\F^k| = |\sol(\C)|$
    and hence $\I|_{\sol(\C)}$ is a bijection.
\end{proof}

The benefit of this bijection is that every solution of $\C$ corresponds to a unique input.
Therefore any question regarding the input and output of a Linicrypt program can be translated to the level of the algebaric representation and solutions of $\C$.
Explicitly, we can formulate the following corollary.

\begin{corollary}
\label{det_solvable_equiv}
    Let $\P = (\I, \O, \C)$ be a deterministic Linicrypt program.
    The following two statements are equivalent:
    \begin{enumerate}
    \item
        Running $\P$ on input $(i_1, \dots, i_k)$ gives output $(o_1, \dots, o_l)$.
    \item 
        There exists a $\vv$ solving $\C$ such that
        $\I\vv = (\dts i k)$ and
        $\O\vv = (\dts o l)$.
    \end{enumerate}
\end{corollary}

\begin{proof}
    The direction 1. $\implies$ 2. is clear, by definition of the algebraic representation.
    
    For the other direction, assume we have such a $\vv \in \Base$.
    If we run $\P$ on $\I\vv = (\dts i k)$ we compute the base variables $\vv' \in \Base$.
    Again by definition of the algebraic representation $\vv'$ is a solution to $\C$ with $\I\vv' = (\dts i k) = \I\vv$.
    By Lemma \ref{solution_space_bijection} $\I|_{\sol(\C)}$ is bijective,
    so we have $\vv = \vv'$.
    Running $\P$ on $(\dts i k)$ gives output $\O\vv' = \O\vv = (\dts o l)$.
\end{proof}


\section{Revisiting Collision Structures}

Using this language we can argue about the invertibility and second preimage resistance of a Linicrypt program.
The goal of this section is to describe collision structures in a more abstract form 
which is easier to adapt to the ideal cipher model.
We will describe collision structures as a program being partially invertible with extra degrees of freedom.
As a stepping stone towards this goal, we start by describing a sufficient condition for a Linicrypt program to be invertible.

\begin{lemma}
\label{inversion}
    $\P = (\I, \O, \C)$ be a deterministic Linicrypt program.
    If $\C$ is deterministically solvable fixing $\O$,
    then $f_\P$ is bijective and $f_\P^{-1}$ is the associated function of a deterministic Linicrypt program which we call $\P^{-1}$.
\end{lemma}

\begin{proof}
Assume $\C$ is deterministically solvable fixing $\O$.
Applying the Lemma \ref{det_solvable_lemma} we get a basis change $\B$
and a Linicrypt program $\P^{-1}$ with algebraic representation $(\O \B, \I \B, \C \B)$.
Note, that $\O$ and $\I$ have the same number of rows, because both $\rows(\I) \cup \{\dts \va n\}$ and
$\rows(\O) \cup \{\dts \va n\}$ are bases of $\F^{1\times\base}$.

Because of the bijection $\B: \sol(\C\B) \to \sol(\C)$ we have the following equivalence:
\begin{gather*}
    \vv \textrm{ solves } \C \textrm{ with }
    \I \vv = \vec i k \textrm{ and } \O \vv = \vec o l \\
    \Updownarrow \\
    \B^{-1} \vv \textrm{ solves } \C \B \textrm{ with }
    \O \B \B^{-1} \vv = \vec o l  \textrm{ and }\I \B \B^{-1} \vv = \vec i k  
\end{gather*}

Combining this equivalence with the one from Lemma \ref{det_solvable_equiv} we get:
Running $\P$ on input $\dts i k$ giving output $\dts o l$ is equivalent to running 
$\P^{-1}$ on input $\dts o l$ with output $\dts i k$.
This means that $f_{\P^{-1}} = f_\P^{-1}$, which is what we needed to prove.
\end{proof}

For example, the Lemma applies to the following program $\P$. 
The proof constructs the algebraic representation of the inverse program $\P^{-1}$.
\begin{pchstack}[center,space=2cm]
    \pcbl[valign=c]{$\P(x,y)$}{
        \pcreturn (y + \H(x), x)
    }
    \pcbl[valign=c]{$\P^{-1}(w,z)$}{
        \pcreturn (z, w - \H(z))
    }
\end{pchstack}

To simplify the following statement about second preimages we introduce a shorthand notation
for all the row vectors contained in a set of constraints $\C$.
We define \[
\rows(\C) = \bigcup_{(t, \Q,\va) \, \in \, \C} \big\{ \rows(\Q) \cup \{ \va \} \big\}.
\]

\begin{lemma}
    Let $\P = (\I, \O, \C)$ be a deterministic Linicrypt program.
    Assume we can write $\C = \Cfix \cup \Ccs$ and
    $\Ccs$ is deterministically solvable fixing some $\I_{cs}$ such that
    \begin{equation}
    \label{cs_condition}
        \spn(\rows(\I_\textrm{cs})) \supset \spn\big(\rows(\Cfix) \cup \rows(\O)\big).
    \end{equation}
    Then an attacker can find second preimages with $\leq n$ queries.
\end{lemma}

This Lemma is similar to Lemma \ref{inversion} in the sense that both describe a condition for being able to find a $\vv$ solving $\C$ while fixing $\O\vv = \vec o l$.
The difference is that here we consider the case where we already have a solution $\vv'$ with $\O \vv' = \vec o l$,
and only require a different one. 

Note, that it is crucial that the space on the left is $\supset$ and not only $\supseteq$,
as this gives the extra degree of freedom to find a different preimage.
It plays the same role as $\vq_{i^*}$ plays in the definition of collision structure from \cite{TCC:McQSwoRos19}.
This characterization includes the case of degeneracy from \cite{TCC:McQSwoRos19},
namely it corresponds to choosing $\Ccs = \{\}$ and $\I_\textrm{cs} = \Id_\base$.
Degeneracy means precisely that $\F^{1\times\base} \supset \spn(\rows(\C) \cup \rows(\O))$.

\begin{proof}
Assume we are given a $\vv'$ solving $\C$ such that $\I \vv' = \vec i k$ and $\O \vv' = \vec o l$.
The goal is to find a different $\vv$ solving $\C$ with $\O \vv = \vec o l$.
By \eqref{cs_condition} we can constrain $\vv$ to fulfill $\O \vv = \O \vv'$
as well as $\Q \vv = \Q \vv'$ and $\va\vv = \va\vv'$ for every $(t, \Q, \va) \in \Cfix\,$.
Even doing so, we still have at least one degree of freedom before we have uniquely determined what
$\I_{cs} \vv$ is.
We can therefore choose these further constraints to be arbitrary such that $\vv \neq \vv'$.
Because $\Ccs$ is deterministically solvable fixing $\I_{cs}$,
we can uniquely determine $\vv$ such that it solves $\Ccs$.
But we chose $\I_{cs} \vv$ in such a way, that $\vv$ also solves $\Cfix\,$,
hence $\vv$ solves $\C = \Ccs \cup \Cfix$.

Finally, because $\P$ is deterministic $\I$ is injective and therefore
$\I\vv$ is a second preimage to $\I\vv'$ for the Linicrypt program $\P$.
\end{proof}

The main benefit of this perspective on the collision structure attack is
that it directly describes the collision structure attack as a Linicrypt program.
If we apply Lemma \ref{det_solvable_lemma} to $\Ccs$ while fixing $\I_{cs}$,
the resulting ``attack program" is one taking as input the desired output,
some values determined by the execution on the given preimage,
and some extra values which can be set freely.

The following is the running example from \cite{TCC:McQSwoRos19}.
\pcb[valign=c]{$\P(x,y,z)$}{
    w = \H(x) + \H(z) + y \\
    \pcreturn (\H(w) + x, \H(z))
}
% TODO fix alignment
\begin{align*}
\I    &= \begin{bmatrix}
            1 & 0 & 0 & 0 & 0 & 0 \\
            0 & 1 & 0 & 0 & 0 & 0 \\
            0 & 0 & 1 & 0 & 0 & 0 
            \end{bmatrix} \\
\O    &= \begin{bmatrix}
            1 & 0 & 0 & 0 & 0 & 1 \\
            0 & 0 & 0 & 0 & 1 & 0 
            \end{bmatrix} \\
\vq_1 &= \begin{bmatrix}1 & 0 & 0 & 0 & 0 & 0\end{bmatrix} \\
\va_1 &= \begin{bmatrix}0 & 0 & 0 & 1 & 0 & 0\end{bmatrix} \\
\vq_2 &= \begin{bmatrix}0 & 0 & 1 & 0 & 0 & 0\end{bmatrix} \\
\va_2 &= \begin{bmatrix}0 & 0 & 0 & 0 & 1 & 0\end{bmatrix} \\
\vq_3 &= \begin{bmatrix}0 & 1 & 0 & 1 & 1 & 0\end{bmatrix} \\
\va_3 &= \begin{bmatrix}0 & 0 & 0 & 0 & 0 & 1\end{bmatrix} \\
\end{align*}

We set $\Ccs = \{ c_1, c_3 \}$ and $\Cfix = \{c_2\}$.
Then $(c_3, c_1)$ is a solution ordering for $\Ccs$ fixing 
\[
\I_{cs} = \begin{bmatrix}\O \\ \vq_2 \\ \vq_3 \end{bmatrix}.
\]
Note, that for this matrix we have fulfilled the required condition \eqref{cs_condition}, because
\[
\spn(\rows(\I_{cs})) \supseteq
\rows(\O) \cup \rows(\Cfix) \cup \{ \vq_3 \},
\]
and $\vq_3$ is linearly independent from the rest on the left hand side.
Then Lemma \ref{det_solvable_lemma} gives us the transformation $\B$
such that $(\I_{cs} \B, \I \B, \Ccs \B)$
is the algebraic representation of some $\P_{cs}$.
Here we have
% TODO fix alignment
\[
\B = 
\begin{bmatrix}
1 & 0 & 0 & 0 &-1 & 0 \\
0 &-1 & 0 & 1 & 0 &-1 \\
0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 \\
0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix},
\]
which leads to the representation:
\begin{align*}
    % TODO fix this constraints mess
    \C_{cs} \B &= \begin{Bmatrix}
        \m{0 & 0 & 0 & 1 &\phantom{-}0 & 0} \mapsto \m{0 & 0 & 0 & 0 & 1 & 0} \} \\
        \m{1 & 0 & 0 & 0 &-1 & 0} \mapsto \m{0 & 0 & 0 & 0 & 0 & 1} \}
    \end{Bmatrix} \\
    \I_\textrm{cs} \B &= \m{\Id_4 & 0} \\
    \I \B &= \begin{bmatrix}
1 & 0 & 0 & 0 &-1 & 0 \\
0 &-1 & 0 & 1 & 0 &-1 \\
0 & 0 & 1 & 0 & 0 & 0
    \end{bmatrix}    
\end{align*}

The corresponding Linicrypt program $\P_{cs}$ to this algebraic representation can be written as:
\pcb[valign=c]{$\P_{cs}(o_1,o_2,q_2, q_3)$}{
    a_3 = \H(q_3) \\
    v = \H(o_1 - a_3) \\
    \pcreturn (o_1 - a_3, q_3 -o_2 - v, q_2)
}

This program computes second preimages to the input $(x,y,z)$
if we set its inputs $(o_1, o_2) = \P(x,y,z)$, $q_2 = z$ and $q_3 \neq H(x) + H(z) + y$ arbitrarily.


\section{Adapting the Linicrypt model to use block ciphers}

In this chapter we modify the Linicrypt model to make use of the ideal cipher model instead of the random oracle model.
This means that a Linicrypt program gets access to a block cipher $\mathcal{E} = (E, D)$ where $E$ and $D$ are functions $\F \times \F \to \F$
instead of the hash function $\H : \{0,1\}^* \times \F^* \to \F$.
By the definition of a block cipher,
$\E_k := \E(k, \cdot)$ is a permutation of $\F$ for all $k \in \F$ and
$\D_k := \D(k, \cdot)$ is its inverse.
In the ideal cipher model, we assume that the block cipher has no weakness.
This is modeled by choosing each permutation $\E_k$ uniformly at random at the beginning of every security game.
We will call these programs with access to a block cipher instead of a hash function ideal cipher Linicrypt programs.

The command $y = \E(k, x)$ in an ideal cipher Linicrypt program has to be treated differently from the command $y = \H(k, x)$ when considering collision resistance,
because an attacker has access to the deterministic Linicrypt program and both directions of the block cipher $\mathcal{E} = (\E, \D)$.
Consider these two programs, $\PH$ in standard Linicrypt and $\PE$ in ideal cipher Linicrypt.

\begin{pchstack}[center,space=2cm]
  \pcbl[valign=c]{$\PH(k, x)$}{
    \pcreturn \H(k,x)
  }
  \pcbl[valign=c]{$\PE(k, x)$}{
    \pcreturn \E(k,x)
  }
\end{pchstack}
While $\PH$ is collision resistant, it is trivial to find second preimages for $\PE$
For any $k' \in \F$ the pair $(k', \D(k', \E(k, x)))$ is a second preimage to $(k,x)$.

This invertibility property of block ciphers has to be taken into account
in both the algebraic representation and the characterization of collision resistance.

\subsection{Algebraic representation for ideal cipher Linicrypt}

Paralell to standard Linicrypt, we will define what the algebraic representation of an ideal cipher Linicrypt program is.
Towards this goal we will make the definitions as in section \ref{revisiting_algebraic_representations}.

\begin{defn}[Ideal cipher oracle constraint]
An \textbf{ideal cipher oracle constraint} of dimension $\base$ taking $m$ inputs is a tuple $(\vk, \vx, \vy)$ for
$\vk, \vx$ and $\vy$ in $\F^{1 \times \base}$.
\end{defn}

We will just say ``constraint" to mean ideal cipher oracle constraint or random oracle constraint depending on the context.

\begin{defn}[Solution of constraints]
    Let $\C$ be a set of ideal cipher constraints of dimension $\base$.
    We say a vector $\vv \in \Base$ \textbf{solves} $\C$ if
    $\vy \vv = \E(\vk \vv, \vx \vv)$ for all $(\vk, \vx, \vy) \in \C$.
    Such a $\vv$ is also called a \textbf{solution} of $\C$.
    The set of all solutions to $\C$ is called $\sol(\C)$.
\end{defn}

Let $\P$ be an ideal cipher Linicrypt program.
Base variables and associated vectors are defined just as with standard Linicrypt.
The only difference is that base variables can now be created with calls to the ideal cipher instead of calls to the random oracle.
For each command in $\P$ of the form $v_3 = \E(v_1,v_2)$
we define the \textbf{associated ideal cipher constraint} $(\vv_1, \vv_2, \vv_3)$.
Note, that the bold variant of the intermediate variable denotes its associated vector.
Correspondingly, each query to $\D$ of the form $v_3 = \D(v_1,v_2)$,
is associated with the constraint $(\vv_1, \vv_3, \vv_2)$.
We call the set of all associated constraints $\C$. 
The input matrix $\I$ and output matrix $\O$ is defined just as with standard Linicrypt.
We call $(\I,\O,\C)$ the algebraic representation of $\P$.
Then, the following statement holds true, which is trivial in the standard case.

\begin{lemma}
    Let $\P$ be an indeal cipher Linicrypt program with algebraic representation $(\I,\O,\C)$.
    Let $\vv$ denote the values of the base variables in an execution of $\P$ with input $(\dts i k)$ and output $(\dts o l)$.
    Then $\vv$ is a solution to $\C$ with $\I\vv = (\dts i k)$ and $\O\vv = (\dts o l)$
\end{lemma}

\begin{proof}
    The statements $\I\vv = (\dts i k)$ and $\O\vv = (\dts o l)$ follow from definition as in standard Linicrypt.
    Each constraint in $\C$ comes from a command in $\P$ with a query to the ideal cipher.
    Take some $(\vk, \vx, \vy) \in \C$.
    It came either from the command $y = \E(k, x)$ or from the command $x = \D(k, y)$.
    In the first case we have $\vy\vv = y = \E(k, x) = \E(\vk\vv, \vx\vv)$.
    In the second case we also have $y = \E(k,x)$
    by the properties of the ideal cipher $\mathcal{E} = (\E,\D)$.
    Therefore $\vv$ solves all constraints in $\C$ and is hence a solution to $\C$.
\end{proof}

TODO

Remove and change everything.

As with standard Linicrypt,
we want to exclude programs that make unnecessary queries to the block cipher.
This way the base variables are linearly independent,
except for the dependencies the adversary might introduce by carefully choosing the input.
Hence we assume wlog that no two constraints have the same $(\E, \v k, \v x)$ or $(\D, \v k, \v y)$.

With ideal ciphers there is a second way to make an unnecessary query.
That is by first computing $y = \E(k,x)$ and then $x' = \D(k, y)$.
As $\D_k$ is the inverse of $\E_k$ we have $x = x'$ although $\v x$ and $\v x'$ are linearly independent.


Therefore for all $\v k, \v x, \v x', \v y, \v y' \in \Base$ we can assume there are no two constraints
$(\E, \v k,\v x, \v y)$ and $(\D, \v k, \v y, \v x')$ in $\C$ for $\v x \neq \v x'$.
Neither can there be $(\D, \v k,\v y, \v x)$ and $(\E, \v k, \v x, \v y')$ in $\C$ for $\v y \neq \v y'$.

TODO: Maybe it is simpler with equivalence relation called always colliding queries
\begin{align*}
    (\E, \v k,\v x, \v y) &\sim (\E, \v k, \v x, \v y') \\ 
    (\E, \v k,\v x, \v y) &\sim (\D, \v k, \v y, \v x') \\
    (\D, \v k,\v y, \v x) &\sim (\D, \v k, \v y, \v x') \\
    (\D, \v k,\v y, \v x) &\sim (\E, \v k, \v x, \v y')
\end{align*}
And saying that no two constraints in $\C$ are in the same equivalence class.
This might be cleaner, if the equivalence relation used later to analyze repeated nonces case is defined similarly.

\section{Collision Structure}

To explain the concept of a collision structure, we will make use of an example.
Consider the following Linicrypt program:
\pcb[valign=c]{$\PE[col,1](a,b,c)$}{
    w = E(c, b+c) + a \\
    \pcreturn c + \E(w,b)
}
A second preimage to $(a,b,c)$ can be found by the following procedure:
Choose some $w' \neq w$.
It will turn out, that even choosing $w'$ at random,
one can calculate what the other base variables need to be such that the output stays the same.
As we want $c + \E(w,b) = c' + \E(w', b')$ we can again choose any $b'$ and compute $c'$. 
Finally, we can compute $a'$ from the equation $w' = \E(c', c' + b') + a'$

One can more easily see that such a procedure is possible by looking at the algebraic representation of $\PE[col,1]$.
In order to highlight which are the base variables, we rewrite the program a bit more explicitly.
\pcb[valign=c]{$\PE[col,1](a,b,c)$}{
    k_1 = c \\
    x_1 = b+c \\
    y_1 = \E(k_1, x_1) \\
    k_2 = y_1 + a \\
    x_2 = b \\
    y_2 = \E(k_2, x_2) \\
    \pcreturn c + y_2
}
The base variables are $(a, b, c, y_1, y_2)$ and the algebraic representation is
\[
    \O = \begin{bmatrix} 0, 0, 1, 0, 1 \end{bmatrix} 
        \qquad \C = \{(\E, \v k_1, \v x_1, \v y_1), (\E, \v k_2, \v x_2, \v y_2)\}
\]
where
\begin{align*}
\v k_1 &= \begin{bmatrix} 0, 0, 1, 0, 0 \end{bmatrix} \\
\v x_1 &= \begin{bmatrix} 0, 1, 1, 0, 0 \end{bmatrix} \\
\v y_1 &= \begin{bmatrix} 0, 0, 0, 1, 0 \end{bmatrix} \\
\v k_2 &= \begin{bmatrix} 1, 0, 0, 1, 0 \end{bmatrix} \\
\v x_2 &= \begin{bmatrix} 0, 1, 0, 0, 0 \end{bmatrix} \\
\v y_2 &= \begin{bmatrix} 0, 0, 0, 0, 1 \end{bmatrix}.
\end{align*}

We can formulate the previous attack from in terms of the algebraic representation.
The task is to find a $\v v_\base' = [a', b', c', y_1', y_2'] \neq \v v_\base$ such that:
\begin{align}
\label{constraint_output}
\PE[col,1](a', b', c') = \O \vbase' &= \O \vbase = \PE[col,1](a,b,c) \\
\label{constraint_cipher_1}
y_1' = \vy_i \vbase' &=  \E(\vk_1 \vbase'\,, \; \vx_1 \vbase')\\
\label{constraint_cipher_2}
y_2' = \vy_i \vbase' &=  \E(\vk_2 \vbase'\,, \; \vx_2 \vbase')
\end{align}

We can fulfill these requirements step by step.
First, we constrain $\vbase'$ by requiring 
\[
    \O \vbase' = \O \vbase.
\]
This reduces the dimension of the space of possible solutions for $\vbase'$ to 4,
as $\O \vbase$ is in the range of $\O$ by definition.
Now note, that neither $\vk_2$ nor $\vx_2$ are in the span of $\rows(\O)$.
Therefore we can choose $k_2'$ and $x_2'$ at random such that $(k_2', x_2') \neq (k_2, x_2)$,
and constrain $\vbase'$ by requiring
\[
    \vk_2 \vbase' = k_2' \quad \textrm{and} \quad \vx_2 \vbase' = x_2'.
\]
Now we can compute $y_2' = \E(k_2', x_2')$ and add constraint \eqref{constraint_cipher_2}.
This constraint is compatible with the previous constraints because $\vy_2$ is not in the span of
$\rows(\O) \cup \{\vk_2, \vx_2\}$.
The dimension of the subspace of solutions is now 1, as we have added 4 one-dimensional constraints.

Now one only needs to fulfill constraint \eqref{constraint_cipher_1}.
As $\vk_1$ and $\vx_1$ are in the span of
$\rows(\O) \cup \{\vk_2, \vx_2, \vy_2\}$ the intermediate variables $k_1'$ and $x_1'$ are uniquely determined.
E.g. $\vk_1 = \O - \vy_2$ and therefore $k_1' = \PE[col,1](a,b,c) - y_2'$.

Finally, note that 
$\vy_1 \notin \spn\big( \rows(\O) \cup \{ \vk_2, \vx_2, \vy_2 \} \cup \{ \vk_1, \vx_1 \} \big)$.
Therefore, adding the constraint
\[
    \vy_1 \vbase' = y_1' = \E(k_1', x_1')
\]
reduces the solution space of possible $\vbase'$ to a single point in $\Base$.
We know that $\vbase' \neq \vbase$ because $(k_2, x_2') \neq (k_2, x_2)$.
The only way to produce different intermediate variables in a deterministic program is to choose different input,
hence $(a',b',c') \neq (a,b,c)$.

This example would have worked exactly the same if we replaced $\E$ with $\H$.
What follows is an example where the invertibility property of $\E_k$ plays a role.

\begin{pchstack}[center, space=2cm]
    \pcbl[valign=c]{$\PE[col,2](a,b,c)$}{
        k_1 = c \\
        x_1 = b \\
        y_1 = \E(k_1, x_1) \\
        k_2 = a \\
        x_2 = y_1 \\
        y_2 = \E(k_2, x_2) \\
        \pcreturn y_1 + y_2
    }
    \pseudocode[valign=c]{
        \O    = \begin{bmatrix}0,0,0,1,1\end{bmatrix} \\
        \vk_1 = \begin{bmatrix}0,0,1,0,0\end{bmatrix} \\
        \vx_1 = \begin{bmatrix}0,1,0,0,0\end{bmatrix} \\
        \vy_1 = \begin{bmatrix}0,0,0,1,0\end{bmatrix} \\
        \vk_2 = \begin{bmatrix}1,0,0,0,0\end{bmatrix} \\
        \vx_2 = \begin{bmatrix}0,0,0,1,0\end{bmatrix} \\
        \vy_2 = \begin{bmatrix}0,0,0,0,1\end{bmatrix} 
    }
\end{pchstack}
For this program there is a similar procedure to find second preimages.
As before, the first constraint is $\O $
In this case we can fix $\vk_2 \vbase' = k_2' = k_2$, $\vx_2 \vbase' = x_2' = x_2$ and $\vy_2 \vbase' = y_2' = y_2$.
Therefore condition \eqref{constraint_cipher_2} is fulfilled trivially.
After adding these 4 constraints the solutions space is still 1-dimensional.
Note, that $\vy_1 = \vx_2$ and it is therefore already fixed at this point,
hence to fulfill \eqref{constraint_cipher_1} we have to make use of the invertibility property of $\E_k$.
Because
\begin{align*}
    \vy_1 \vbase' &= \E(\vk_1 \vbase', \vx_1 \vbase') \\
    \iff \vx_1 \vbase' &= \D(\vk_1 \vbase', \vy_1 \vbase'),
\end{align*}
we can choose a random $k_1' \neq k_1$ and compute $x_1' = \D(k_1', y_1')$ in order to fulfill (3.1).
With this fifth constraint we have found a single $\vbase' \neq \vbase$.

We want to briefly summarize the conditions for this kind of second preimage attack.
Let $\P'$ denote the execution of 
\begin{itemize}
\item
    Some ideal cipher constraints are fulfilled by setting the intermediate variables in $\P(a',b',c')$ to the same value as in $\P(a,b,c)$ 
\item
    There is some constraint for which either the input or the output is undetermined by the previously fixed intermediate variables
\item
    For this constraint and all following constraint one can iteratively call the ideal cipher $\BC$ to set the intermediate variables such that the constraints are fulfilled.
    This is only possible, if the either the output or the input is undetermined by previously fixed variables.
\end{itemize}


\begin{defn}[Collision structure]
Let $\P = (\O, \C)$ be a Linicrypt program with $|\C| = n$.
A \textbf{collision structure} for $\P$ is an index $1 \leq i^* \leq n$, an ordering $(c_1, \dots, c_n)$ of $\C$ for $c_i = (Op_i, \v k_i, \v q_i,\v a_i)$
and a tuple $(dir_{i^*}, \dots, dir_n)$ for $dir_i \in \{\For, \Back\}$,
such that the following two conditions hold:
\begin{enumerate}
\item 
Let $\mathcal{F}_\is = \{
    \v k_1, \dots, \v k_{i^* -1},
    \v q_1, \dots, \v q_{i^* -1},
    \v a_1, \dots, \v a_{i^* -1}
    \}$. One of the following is true:
        \begin{enumerate}
    \item $dir_\is = \For \quad$ and 
        $\quad
            \spn\big(\{ \v k_{i^*}, \v q_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F}_\is \cup \rows\left(\O\right) \big)
        $
    \item $dir_\is = \Back \quad$ and 
        $\quad
            \spn\big(\{ \v k_{i^*}, \v a_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F}_\is \cup \rows\left(\O\right) \big)
        $
\end{enumerate}
\item For all $j \geq i^*$ let $\mathcal{F}_j = \{
    \v k_1, \dots, \v k_{j -1},
    \v q_1, \dots, \v q_{j -1},
    \v a_1, \dots, \v a_{j -1}
    \}$. One of the following is true:
\begin{enumerate}
    \item $dir_j = \For \quad$ and 
        $\quad
        \v a_j \notin \spn\big(
        \mathcal{F}_j
        \cup \{ \v k_j, \v q_j\}
        \cup \rows\left(\O\right)
        \big)
        $
    \item $dir_j = \Back \quad$ and 
        $\quad
        \v q_j \notin \spn\big(
        \mathcal{F}_j
        \cup \{ \v k_j, \v a_j\}
        \cup \rows\left(\O\right)
        \big)
        $
\end{enumerate}
\end{enumerate}
\end{defn}

TODO: Remove this wordy definition.
All the info from here should be integrated into the example

\begin{defn}[Collision structure]
Let $\P = (\O, \C)$ be a Linicrypt program with $|\C| = n$.
A \textbf{collision structure} for $\P$ is an index $1 \leq i^* \leq n$, an ordering $(c_1, \dots, c_n)$ of $\C$ for $c_i = (Op_i, \v k_i, \v q_i,\v a_i)$
and a tuple $(dir_{i^*}, \dots, dir_n)$ for $dir_i \in \{\For, \Back\}$,
such that:
\begin{enumerate}
\item The $i^*$'th constraint is unconstrained by the output of $\P$ and previous fixed constraints.
Let $\mathcal{F} = \{
    \v k_1, \dots, \v k_{i^* -1},
    \v q_1, \dots, \v q_{i^* -1},
    \v a_1, \dots, \v a_{i^* -1}
    \}$
denote the vectors fixed by previous constraints in the ordering.
\begin{enumerate}
    \item if $dir_\is = \For$, the input of the query associated to $c_\is$ is unconstrained:
        \[
            \spn\big(\{ \v k_{i^*}, \v q_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F} \cup \rows\left(\O\right) \big)
        \]
    \item if $dir_\is = \Back$, the output of the query associated to $c_\is$ is unconstrained:
        \[
            \spn\big(\{ \v k_{i^*}, \v a_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F} \cup \rows\left(\O\right) \big)
        \]
\end{enumerate}
\item For all $j \geq i^*$ the constraint $c_j$ does not contradict previous constraints.
Let $\mathcal{F} = \{
    \v k_1, \dots, \v k_{j -1},
    \v q_1, \dots, \v q_{j -1},
    \v a_1, \dots, \v a_{j -1}
    \}$
denote the vectors fixed by previous constraints in the ordering.
\begin{enumerate}
    \item if $dir_j = \For$
        \[
        \v a_j \notin \spn\big( \{
        \v k_1, \dots, \v k_{j -1},
        \v q_1, \dots, \v q_{j -1},
        \v a_1, \dots, \v a_{j -1},
        \} 
        \cup \{ \v k_j, \v q_j\}
        \cup \rows\left(\O\right)
        \big)
        \]
    \item if $dir_j = \Back$
        \[
        \v q_j \notin \spn\big( \{
        \v k_1, \dots, \v k_{j -1},
        \v q_1, \dots, \v q_{j -1},
        \v a_1, \dots, \v a_{j -1},
        \} 
        \cup \{ \v k_j, \v a_j\}
        \cup \rows\left(\O\right)
        \big)
        \]
\end{enumerate}
\end{enumerate}
\end{defn}

\begin{lemma}[Collision structure gives second preimages]
    If collision structure blabla exists for $\P = (\O, \C)$ then blabla with probability 1.
\end{lemma}

\pcb[mode=text]{$\mathsf{FindSecondPreimage}\Big(\Big)$}{
Compute $\vbase$ by executing $\PE(\vx)$  \\
... very similar
}
