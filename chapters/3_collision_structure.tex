\chapter{Linicrypt with Ideal Ciphers}

\section{Revisiting Algebraic Representations}
We have defined the algebraic representation for a Linicrypt program.
It consists of the input matrix $\Inp \in \F^{k \times \base}$,
the output matrix $\M \in \F^{l \times \base}$
and the set of constraints $\C = \{ (t_i, \Q_i, \va_i) \mid i = 1, \dots, n \}$,
with $\Q_i \in \F^{m_i \times \base}$ and $\va_i \in \F^{1 \times \base}$.
A question that arises is:
Which combination of matrices this described structure correspond to a Linicrypt program?
To answer this question, we need to define the terminology more carefully.

\begin{defn}[Random oracle constraing]
A \textbf{random oracle constraint} of dimension $\base$ with $k$ inputs is a tuple $(t, \v Q, \v a)$ for
$t \in \bin^*$, $\Q \in \F^{k \times \base}$ and $\va \in \F^{1 \times \base}$.
\end{defn}

We call $t$ the nonce and refer to $\Q$ and $\va$ as the query and answer to the random oracle.
Usually we just say constraint when the other variables are clear from the context.
The constraints $(t, \Q, \va)$ encodes a relationship between the base variables $\vbase \in \Base$ of a program,
namely $\H(t, \Q \vbase) = \va \vbase$.
Because $\H$ is a well-defined function,
and not just any relation,
these requirements extend to the constraints.

\begin{defn}[Well-defined]
A set of (random oracle) constraints $\C$ is \textbf{well-defined} if for any pair of constraints 
$c_i, c_j \in \C$ we have $(t_i,\Q_i) = (t_j, \Q_j) \implies \va_i = \va_j$.
\end{defn}

When we use a set of constraints, we will implicitly also require that it is well-defined.
Highlighting the function like properties of a constraint $(t, \Q, \va)$,
we will also use the shorthand $(t,\Q) \mapsto \va$ or $\Q \mapsto \va$ if $t$ is an empty string.
This notation was introduced in \cite{CSF:HolRosRoy22}.
If a set of constraints is well-defined, it might still not correspond to a valid Linicrypt program.
Consider the set
\[
\C = \left\{ \m{1&0} \mapsto \m{0&1}, \m{0&1} \mapsto \m{1&0}\right\}.
\]
Although it is well-defined,
it corresponds to the requirement that $\H(\H(x)) = x$
for some $x \in \F$.
Such an $x$ might not exists in the first place,
and if it does,
no efficient program can find it in the random oracle model.

In order to characterize which constraints can be solved by a Linicrypt program,
we also need to consider the concept of basis change as introduced in \cite{C:CarRos16}.

\begin{defn}[Basis change]
    Let $\v B$ be any matrix in $\F^{\base \times \base}$
    and $\P = (\Inp, \M, \C)$ be a Linicrypt program.
    We define 
    \[
        \C \B \coloneqq \big\{ (t, \Q \B, \va \B) \mid (t, \Q, \va) \in \C \big\}.
    \]
    If $\B$ is invertible,
    we say $(\Inp \B, \M \B, \C \B)$ is the algebraic representation of $\P$
    after applying the \textbf{basis change} $\B$.
\end{defn}

In the case that $\B$ is just a permutation of the input variables
the transformed representation clearly describes the same program,
we have just renamed the input variables.
But a more complex basis changes won't change the program either, as is shown below.

Now we can characterize which sets of constraints and input matrices correspond to a Linicrypt program.

\begin{defn}[Solvable]
Let $\C$ be a finite set of valid constraints of dimension $\base$,
and let $\Inp \in \F^{k \times \base}$ for some $k \in \NN$.
$\C$ is deterministically solvable fixing $\Inp$
if there exists an ordering $(c_1, \dots, c_n)$ of $\C$
such that for all $i=1, \dots n$:
\begin{enumerate}
\item
    \label{solvable1}
    $\rows(\Q_i) \subset \spn \big(\rows(\Inp) \cup \{\va_1, \dots, \va_{i-1}\}\big)$
\item
    \label{solvable2}
    $\va_i \notin \spn \big(\rows(\Inp) \cup \{\va_1, \dots, \va_{i-1}\} \cup \rows(\Q_i) \big)$
\end{enumerate}
We call $(c_1, \dots, c_n)$ the solution ordering of $\C$ fixing $\Inp$ (or fixing $\rows(\Inp)$).
\end{defn}

This is a generalization of the idea of the collision structure in \cite{TCC:McQSwoRos19}.
We will use it to generalize the collision structure and degeneracy attacks from that work.

Intuitively, $\C$ being solvable fixing $\Inp$ means,
that we can constrain $\vbase$ by $\Inp \vbase = (i_1, \dots, i_k)^\top$ for arbitrary inputs $i_1, \dots, i_k \in \F$,
and then compute each oracle query (condition \ref{solvable1}),
without creating a contradiction (condition \ref{solvable2}).


% TODO in general it is unclear if P is deterministic or not. I think everything works for
% non deterministic programs too, just more cumbersome and useless for my purpose.
If we construct the algebraic representation $(\Inp, \M, \C)$ of a deterministic Linicrypt program $\P$,
we get a solvable set of constraints.
Indeed, the solution ordering of $\C$ fixing $\Inp$
can be exactly the order of the corresponding queries in the execution of $\P$.
The following Lemma shows that the other direction also works,
meaning that we can recover a Linicrypt program from solvable constraints.

% TODO add name?
\begin{lemma}
\label{solvable}
    Let $\C$ be a set of deterministically solvable constraints fixing $\Inp \in \F^{k \times \base}$ for some $k \in \NN$.
    Let $\M \in \F^{\out \times \base}$ be an arbitrary output matrix for some $\out \in \NN$.
    Then there is a basis change $\B \in \F^{\base \times \base}$
    and a Linicrypt program $\P$,
    % TODO it doesnt actually matter that M is transformed, as it is arbitray anyways... Which way is less confusing? Probably without B, even though it is less visually pleasing
    such that $(\Inp \B, \M \B, \C \B)$ is it's algebraic representation.
\end{lemma}

\begin{proof}
Let $(\vi_1, \dots, \vi_k) = \rows(I)$ let $(c_1, \dots, c_n)$ be the solution ordering of $\C$ fixing $\I$.
% TODO wording, basis change matrix?
We choose the new basis for $\Base$ as $(\vi_1, \dots, \vi_k, \va_1, \dots, \va_n)$, hence the basis change matrix is defined by
\[
    \B^{-1} = 
    \begin{bmatrix}
\vi_1 &
\cdots &
\vi_k &
\va_1 &
\cdots &
\va_n
    \end{bmatrix}^\top.
\]

In the following we denote by $\v e_i$ the i'th canonical row vector.
By definition of $\B$ we have for $i=1, \dots, n$
% TODO this is not compact enough, for its importance
\begin{equation*}
\I = \begin{bmatrix}
    \v e_1 \\
    \vdots \\
    \v e_k
\end{bmatrix} \B^{-1}
\qquad \textrm{and} \qquad
\va_i = \v e_{k+i} \B^{-1},
\end{equation*}
which is equivalent to
\begin{equation*}
\I \B = \begin{bmatrix}
    \v e_1 \\
    \vdots \\
    \v e_k
\end{bmatrix}
\qquad \textrm{and} \qquad
\va_i \B = \v e_{k+i}.
\end{equation*}

Additionally, as $\C$ is solvable via the ordering $(c_1, \dots, c_n)$,
we know that 
\[
\rows(\Q_i \B) \subset \spn\big( \ve_1, \dots, \ve_{k+i-1} \big)
\]

In other words, the query and answer matrices for the constraints in $\C \B$ have the form
\begin{align*}
\Q_i &= \begin{bmatrix} \parbox{12pt}{$\lambda^i_1$} & \cdots & \parbox{32pt}{$\lambda^i_{k+i-1}$} & 0 & 0 & \cdots & 0 \end{bmatrix} \qquad \textrm{for} \quad \lambda^i_j \in \F \\
\va_i &= \begin{bmatrix} \parbox{12pt}{0}            & \cdots & \parbox{32pt}{0}                 & 1 & 0 & \cdots & 0 \end{bmatrix}
\end{align*}

Both the input matrix $\I \B$ and $\C \B$ have the correct form to be 
the algebraic representation of a program $\P$ taking $k$ inputs,
and outputting according to $\M \B$.
\end{proof}


\section{Revisiting Collision Structures}
Using this language we can argue about the invertibility and second preimage resistance of a Linicrypt program.
Let $\P = (\I, \M, \C)$ be a Linicrypt program.

\begin{lemma}
    $\P$ is deterministically invertible if $\C$ is solvable fixing $\M$.
\end{lemma}

\begin{proof}
By Lemma \ref{solvable} we get a Linicrypt program $\P^{-1}$ with algebraic representation $(\M \B, \I \B, \C \B)$.
By inputting $(o_1, \dots, o_l)$ into $\P^{-1}$ the program computes the values of $\vbase$.
As $\vbase$ solves $\C\B$ with $\I\B \vbase = (i_1, \dots, i_k)^\top$ and $\M\B \vbase = (o_1, \dots, o_l)^\top$,
it follows from associativity that $\B\vbase$ solves $\C$ with $\I (\B\vbase) = (i_1, \dots, i_k)^\top$.
Therefore, if we run $\P$ with input $(i_1, \dots, i_k)$ we will get the output $(o_1, \dots, o_l)$.
\end{proof}
TODO this proof needs to be expanded, it relies on defining ``$\vv$ solves $\C$" and proving that
if $\vv$ solves $\C$ then running $\P$ on $\I \vv$ we get $\M \vv$ as output.
This is kind of obvious, but the proof I found is not super trivial, let's talk about it.

To simplify the following statements we introduce a shorthand for all the row vectors contained in a set of constraints $\C$.
We will write \[
\rows(\C) = \bigcup_{(\Q,\va) \, \in \, \C} \big\{ \rows(\Q) \cup \{ \va \} \big\}
\]

\begin{lemma}
    One can find second preimages for $\P$ with $\leq n$ queries
    if $\C = \Cfix \sqcup \Ccs$ such that
    $\C_\textrm{cs}$ is solvable fixing a matrix $\I_\textrm{cs}$ such that
    \begin{equation}
        \spn(\rows(\I_\textrm{cs})) \supset \spn\big(\rows(\C_\textrm{fixed}) \cup \rows(\M)\big).
    \end{equation}
\end{lemma}
\begin{proof}
TODO, but same idea, using Lemma \ref{solvable}
\end{proof}

Note, that it is crucial that the space on the left is $\supset$ and not only $\supseteq$,
as this gives the extra degree of freedom to find a different preimage.
It plays the same role as $\vq_{i^*}$ plays in the definition of collision structure from \cite{TCC:McQSwoRos19}.
This characterization includes the case of degeneracy,
namely it corresponds to choosing $\Ccs = \{\}$ and $\I_\textrm{cs} = \Id_\base$,
while degeneracy means precisely $\Base \supset \spn(\rows(\C) \cup \rows(\M))$.

The main benefit of this perspective on the collision structure attack is,
that it describes the Linicrypt program which produces the second preimages.

The following is the running example from \cite{TCC:McQSwoRos19}.
\pcb[valign=c]{$\P(x,y,z)$}{
    w = \H(x) + \H(z) + y \\
    \pcreturn (\H(w) + x, \H(z))
}
% TODO fix alignment
\begin{align*}
\I    &= \begin{bmatrix}
            1 & 0 & 0 & 0 & 0 & 0 \\
            0 & 1 & 0 & 0 & 0 & 0 \\
            0 & 0 & 1 & 0 & 0 & 0 
            \end{bmatrix} \\
\M    &= \begin{bmatrix}
            1 & 0 & 0 & 0 & 0 & 1 \\
            0 & 0 & 0 & 0 & 1 & 0 
            \end{bmatrix} \\
\vq_1 &= \begin{bmatrix}1 & 0 & 0 & 0 & 0 & 0\end{bmatrix} \\
\va_1 &= \begin{bmatrix}0 & 0 & 0 & 1 & 0 & 0\end{bmatrix} \\
\vq_2 &= \begin{bmatrix}0 & 0 & 1 & 0 & 0 & 0\end{bmatrix} \\
\va_2 &= \begin{bmatrix}0 & 0 & 0 & 0 & 1 & 0\end{bmatrix} \\
\vq_3 &= \begin{bmatrix}0 & 1 & 0 & 1 & 1 & 0\end{bmatrix} \\
\va_3 &= \begin{bmatrix}0 & 0 & 0 & 0 & 0 & 1\end{bmatrix} \\
\end{align*}

We set $\Ccs = \{ c_1, c_3 \}$ and $\Cfix = \{c_2\}$.
Then $(c_3, c_1)$ is a solution ordering for $\C$ fixing the row vectors
% TODO notation, thsi is not linear independet, fix solvable again ...
\[
\rows(\M) \cup \rows(\Cfix) \cup \{ \vq_3 \}.
\]
We then concatenate these rows to form the input matrix of the attacking program:
% TODO explain why a_2 not in here, linear dependent
$\I_\textrm{cs} = \begin{bmatrix}\M & \vq_2 & \vq_3 \end{bmatrix}^\top$.
Then Lemma \ref{solvable} gives us the transformation $\B$
such that $(\I_\textrm{cs} \B, \I \B, \Ccs \B)$
is the algebraic representation of some $\P_\textrm{col}$.
Here we have
% TODO fix alignment
\[
\B = 
\begin{bmatrix}
1 & 0 & 0 & 0 &-1 & 0 \\
0 &-1 & 0 & 1 & 0 &-1 \\
0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 \\
0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix},
\]
which leads to the representation:
\begin{align*}
    % TODO fix this constraints mess
    \C_{cs} \B &= \begin{Bmatrix}
        \m{0 & 0 & 0 & 1 &\phantom{-}0 & 0} \mapsto \m{0 & 0 & 0 & 0 & 1 & 0} \} \\
        \m{1 & 0 & 0 & 0 &-1 & 0} \mapsto \m{0 & 0 & 0 & 0 & 0 & 1} \}
    \end{Bmatrix} \\
    \I_\textrm{cs} \B &= \m{\Id_4 & 0} \\
    \I \B &= \begin{bmatrix}
1 & 0 & 0 & 0 &-1 & 0 \\
0 &-1 & 0 & 1 & 0 &-1 \\
0 & 0 & 1 & 0 & 0 & 0
    \end{bmatrix}    
\end{align*}

In the form of a Linicryp program this is:
\pcb[valign=c]{$\P_\textrm{col}(o_1,o_2,z, q_3)$}{
    a_3 = \H(q_3) \\
    v = \H(o_1 - a_3) \\
    \pcreturn (o_1 - a_3, q_3 -o_2 - v, z)
}


\section{Adapting the Linicrypt model to use block ciphers}

In this chapter we modify the Linicrypt model to make use of the ideal cipher model instead of the random oracle model.
This means that a Linicrypt program gets access to a block cipher $\mathcal{E} = (E, D)$ where $E$ and $D$ are functions $\F \times \F \to \F$
instead of the hash function $\H : \{0,1\}^* \times \F^* \to \F$.
By the definition of a block cipher,
$\E_k := \E(k, \cdot)$ is a permutation of $\F$ for all $k \in \F$ and
$\D_k := \D(k, \cdot)$ is its inverse.
In the ideal cipher model, we assume that the block cipher has no weakness.
This is modeled by choosing each permutation $\E_k$ uniformly at random at the beginning of every security game.

The command $y = \E(k, x)$ in a Linicrypt program has to be treated differently from the command $y = \H(k, x)$ when considering collision resistance,
because an attacker has access to the deterministic Linicrypt program and both directions of the block cipher $\mathcal{E} = (\E, \D)$.
Consider these two programs, $\PH$ in standard Linicrypt and $\PE$ in ideal cipher Linicrypt.

\begin{pchstack}[center,space=2cm]
  \pcbl[valign=c]{$\PH(k, x)$}{
    \pcreturn \H(k,x)
  }
  \pcbl[valign=c]{$\PE(k, x)$}{
    \pcreturn \E(k,x)
  }
\end{pchstack}
While $\PH$ is collision resistant, it is trivial to find second preimages for $\PE$
For any $k' \in \F$ the pair $(k', \D(k', \E(k, x)))$ is a second preimage to $(k,x)$.

This invertibility property of block ciphers has to be taken into account
in both the algebraic representation and the characterization of collision resistance.

\subsection{Algebraic representation for ideal cipher Linicrypt}

Let $\P$ be a ideal cipher Linicrypt program. For each query to $\E$ of the form $y =
\E(k,x)$ we define the \textbf{associated ideal cipher constraint} $(\E, \v k, \v x, \v y)$.
Each query to $\D$ of the form $x = \D(k, y)$, is
associated with the constraint $(\D, \v k, \v y, \v x)$.

As with standard Linicrypt,
we want to exclude programs that make unnecessary queries to the block cipher.
This way the base variables are linearly independent,
except for the dependencies the adversary might introduce by carefully choosing the input.
Hence we assume wlog that no two constraints have the same $(\E, \v k, \v x)$ or $(\D, \v k, \v y)$.

With ideal ciphers there is a second way to make an unnecessary query.
That is by first computing $y = \E(k,x)$ and then $x' = \D(k, y)$.
As $\D_k$ is the inverse of $\E_k$ we have $x = x'$ although $\v x$ and $\v x'$ are linearly independent.


Therefore for all $\v k, \v x, \v x', \v y, \v y' \in \Base$ we can assume there are no two constraints
$(\E, \v k,\v x, \v y)$ and $(\D, \v k, \v y, \v x')$ in $\C$ for $\v x \neq \v x'$.
Neither can there be $(\D, \v k,\v y, \v x)$ and $(\E, \v k, \v x, \v y')$ in $\C$ for $\v y \neq \v y'$.

TODO: Maybe it is simpler with equivalence relation called always colliding queries
\begin{align*}
    (\E, \v k,\v x, \v y) &\sim (\E, \v k, \v x, \v y') \\ 
    (\E, \v k,\v x, \v y) &\sim (\D, \v k, \v y, \v x') \\
    (\D, \v k,\v y, \v x) &\sim (\D, \v k, \v y, \v x') \\
    (\D, \v k,\v y, \v x) &\sim (\E, \v k, \v x, \v y')
\end{align*}
And saying that no two constraints in $\C$ are in the same equivalence class.
This might be cleaner, if the equivalence relation used later to analyze repeated nonces case is defined similarly.

\section{Collision Structure}

To explain the concept of a collision structure, we will make use of an example.
Consider the following Linicrypt program:
\pcb[valign=c]{$\PE[col,1](a,b,c)$}{
    w = E(c, b+c) + a \\
    \pcreturn c + \E(w,b)
}
A second preimage to $(a,b,c)$ can be found by the following procedure:
Choose some $w' \neq w$.
It will turn out, that even choosing $w'$ at random,
one can calculate what the other base variables need to be such that the output stays the same.
As we want $c + \E(w,b) = c' + \E(w', b')$ we can again choose any $b'$ and compute $c'$. 
Finally, we can compute $a'$ from the equation $w' = \E(c', c' + b') + a'$

One can more easily see that such a procedure is possible by looking at the algebraic representation of $\PE[col,1]$.
In order to highlight which are the base variables, we rewrite the program a bit more explicitly.
\pcb[valign=c]{$\PE[col,1](a,b,c)$}{
    k_1 = c \\
    x_1 = b+c \\
    y_1 = \E(k_1, x_1) \\
    k_2 = y_1 + a \\
    x_2 = b \\
    y_2 = \E(k_2, x_2) \\
    \pcreturn c + y_2
}
The base variables are $(a, b, c, y_1, y_2)$ and the algebraic representation is
\[
    \M = \begin{bmatrix} 0, 0, 1, 0, 1 \end{bmatrix} 
        \qquad \C = \{(\E, \v k_1, \v x_1, \v y_1), (\E, \v k_2, \v x_2, \v y_2)\}
\]
where
\begin{align*}
\v k_1 &= \begin{bmatrix} 0, 0, 1, 0, 0 \end{bmatrix} \\
\v x_1 &= \begin{bmatrix} 0, 1, 1, 0, 0 \end{bmatrix} \\
\v y_1 &= \begin{bmatrix} 0, 0, 0, 1, 0 \end{bmatrix} \\
\v k_2 &= \begin{bmatrix} 1, 0, 0, 1, 0 \end{bmatrix} \\
\v x_2 &= \begin{bmatrix} 0, 1, 0, 0, 0 \end{bmatrix} \\
\v y_2 &= \begin{bmatrix} 0, 0, 0, 0, 1 \end{bmatrix}.
\end{align*}

We can formulate the previous attack from in terms of the algebraic representation.
The task is to find a $\v v_\base' = [a', b', c', y_1', y_2'] \neq \v v_\base$ such that:
\begin{align}
\label{constraint_output}
\PE[col,1](a', b', c') = \M \vbase' &= \M \vbase = \PE[col,1](a,b,c) \\
\label{constraint_cipher_1}
y_1' = \vy_i \vbase' &=  \E(\vk_1 \vbase'\,, \; \vx_1 \vbase')\\
\label{constraint_cipher_2}
y_2' = \vy_i \vbase' &=  \E(\vk_2 \vbase'\,, \; \vx_2 \vbase')
\end{align}

We can fulfill these requirements step by step.
First, we constrain $\vbase'$ by requiring 
\[
    \M \vbase' = \M \vbase.
\]
This reduces the dimension of the space of possible solutions for $\vbase'$ to 4,
as $\M \vbase$ is in the range of $\M$ by definition.
Now note, that neither $\vk_2$ nor $\vx_2$ are in the span of $\rows(\M)$.
Therefore we can choose $k_2'$ and $x_2'$ at random such that $(k_2', x_2') \neq (k_2, x_2)$,
and constrain $\vbase'$ by requiring
\[
    \vk_2 \vbase' = k_2' \quad \textrm{and} \quad \vx_2 \vbase' = x_2'.
\]
Now we can compute $y_2' = \E(k_2', x_2')$ and add constraint \eqref{constraint_cipher_2}.
This constraint is compatible with the previous constraints because $\vy_2$ is not in the span of
$\rows(\M) \cup \{\vk_2, \vx_2\}$.
The dimension of the subspace of solutions is now 1, as we have added 4 one-dimensional constraints.

Now one only needs to fulfill constraint \eqref{constraint_cipher_1}.
As $\vk_1$ and $\vx_1$ are in the span of
$\rows(\M) \cup \{\vk_2, \vx_2, \vy_2\}$ the intermediate variables $k_1'$ and $x_1'$ are uniquely determined.
E.g. $\vk_1 = \M - \vy_2$ and therefore $k_1' = \PE[col,1](a,b,c) - y_2'$.

Finally, note that 
$\vy_1 \notin \spn\big( \rows(\M) \cup \{ \vk_2, \vx_2, \vy_2 \} \cup \{ \vk_1, \vx_1 \} \big)$.
Therefore, adding the constraint
\[
    \vy_1 \vbase' = y_1' = \E(k_1', x_1')
\]
reduces the solution space of possible $\vbase'$ to a single point in $\Base$.
We know that $\vbase' \neq \vbase$ because $(k_2, x_2') \neq (k_2, x_2)$.
The only way to produce different intermediate variables in a deterministic program is to choose different input,
hence $(a',b',c') \neq (a,b,c)$.

This example would have worked exactly the same if we replaced $\E$ with $\H$.
What follows is an example where the invertibility property of $\E_k$ plays a role.

\begin{pchstack}[center, space=2cm]
    \pcbl[valign=c]{$\PE[col,2](a,b,c)$}{
        k_1 = c \\
        x_1 = b \\
        y_1 = \E(k_1, x_1) \\
        k_2 = a \\
        x_2 = y_1 \\
        y_2 = \E(k_2, x_2) \\
        \pcreturn y_1 + y_2
    }
    \pseudocode[valign=c]{
        \M    = \begin{bmatrix}0,0,0,1,1\end{bmatrix} \\
        \vk_1 = \begin{bmatrix}0,0,1,0,0\end{bmatrix} \\
        \vx_1 = \begin{bmatrix}0,1,0,0,0\end{bmatrix} \\
        \vy_1 = \begin{bmatrix}0,0,0,1,0\end{bmatrix} \\
        \vk_2 = \begin{bmatrix}1,0,0,0,0\end{bmatrix} \\
        \vx_2 = \begin{bmatrix}0,0,0,1,0\end{bmatrix} \\
        \vy_2 = \begin{bmatrix}0,0,0,0,1\end{bmatrix} 
    }
\end{pchstack}
For this program there is a similar procedure to find second preimages.
As before, the first constraint is $\M $
In this case we can fix $\vk_2 \vbase' = k_2' = k_2$, $\vx_2 \vbase' = x_2' = x_2$ and $\vy_2 \vbase' = y_2' = y_2$.
Therefore condition \eqref{constraint_cipher_2} is fulfilled trivially.
After adding these 4 constraints the solutions space is still 1-dimensional.
Note, that $\vy_1 = \vx_2$ and it is therefore already fixed at this point,
hence to fulfill \eqref{constraint_cipher_1} we have to make use of the invertibility property of $\E_k$.
Because
\begin{align*}
    \vy_1 \vbase' &= \E(\vk_1 \vbase', \vx_1 \vbase') \\
    \iff \vx_1 \vbase' &= \D(\vk_1 \vbase', \vy_1 \vbase'),
\end{align*}
we can choose a random $k_1' \neq k_1$ and compute $x_1' = \D(k_1', y_1')$ in order to fulfill (3.1).
With this fifth constraint we have found a single $\vbase' \neq \vbase$.

We want to briefly summarize the conditions for this kind of second preimage attack.
Let $\P'$ denote the execution of 
\begin{itemize}
\item
    Some ideal cipher constraints are fulfilled by setting the intermediate variables in $\P(a',b',c')$ to the same value as in $\P(a,b,c)$ 
\item
    There is some constraint for which either the input or the output is undetermined by the previously fixed intermediate variables
\item
    For this constraint and all following constraint one can iteratively call the ideal cipher $\BC$ to set the intermediate variables such that the constraints are fulfilled.
    This is only possible, if the either the output or the input is undetermined by previously fixed variables.
\end{itemize}


\begin{defn}[Collision structure]
Let $\P = (\M, \C)$ be a Linicrypt program with $|\C| = n$.
A \textbf{collision structure} for $\P$ is an index $1 \leq i^* \leq n$, an ordering $(c_1, \dots, c_n)$ of $\C$ for $c_i = (Op_i, \v k_i, \v q_i,\v a_i)$
and a tuple $(dir_{i^*}, \dots, dir_n)$ for $dir_i \in \{\For, \Back\}$,
such that the following two conditions hold:
\begin{enumerate}
\item 
Let $\mathcal{F}_\is = \{
    \v k_1, \dots, \v k_{i^* -1},
    \v q_1, \dots, \v q_{i^* -1},
    \v a_1, \dots, \v a_{i^* -1}
    \}$. One of the following is true:
        \begin{enumerate}
    \item $dir_\is = \For \quad$ and 
        $\quad
            \spn\big(\{ \v k_{i^*}, \v q_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F}_\is \cup \rows\left(\M\right) \big)
        $
    \item $dir_\is = \Back \quad$ and 
        $\quad
            \spn\big(\{ \v k_{i^*}, \v a_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F}_\is \cup \rows\left(\M\right) \big)
        $
\end{enumerate}
\item For all $j \geq i^*$ let $\mathcal{F}_j = \{
    \v k_1, \dots, \v k_{j -1},
    \v q_1, \dots, \v q_{j -1},
    \v a_1, \dots, \v a_{j -1}
    \}$. One of the following is true:
\begin{enumerate}
    \item $dir_j = \For \quad$ and 
        $\quad
        \v a_j \notin \spn\big(
        \mathcal{F}_j
        \cup \{ \v k_j, \v q_j\}
        \cup \rows\left(\M\right)
        \big)
        $
    \item $dir_j = \Back \quad$ and 
        $\quad
        \v q_j \notin \spn\big(
        \mathcal{F}_j
        \cup \{ \v k_j, \v a_j\}
        \cup \rows\left(\M\right)
        \big)
        $
\end{enumerate}
\end{enumerate}
\end{defn}

TODO: Remove this wordy definition.
All the info from here should be integrated into the example

\begin{defn}[Collision structure]
Let $\P = (\M, \C)$ be a Linicrypt program with $|\C| = n$.
A \textbf{collision structure} for $\P$ is an index $1 \leq i^* \leq n$, an ordering $(c_1, \dots, c_n)$ of $\C$ for $c_i = (Op_i, \v k_i, \v q_i,\v a_i)$
and a tuple $(dir_{i^*}, \dots, dir_n)$ for $dir_i \in \{\For, \Back\}$,
such that:
\begin{enumerate}
\item The $i^*$'th constraint is unconstrained by the output of $\P$ and previous fixed constraints.
Let $\mathcal{F} = \{
    \v k_1, \dots, \v k_{i^* -1},
    \v q_1, \dots, \v q_{i^* -1},
    \v a_1, \dots, \v a_{i^* -1}
    \}$
denote the vectors fixed by previous constraints in the ordering.
\begin{enumerate}
    \item if $dir_\is = \For$, the input of the query associated to $c_\is$ is unconstrained:
        \[
            \spn\big(\{ \v k_{i^*}, \v q_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F} \cup \rows\left(\M\right) \big)
        \]
    \item if $dir_\is = \Back$, the output of the query associated to $c_\is$ is unconstrained:
        \[
            \spn\big(\{ \v k_{i^*}, \v a_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F} \cup \rows\left(\M\right) \big)
        \]
\end{enumerate}
\item For all $j \geq i^*$ the constraint $c_j$ does not contradict previous constraints.
Let $\mathcal{F} = \{
    \v k_1, \dots, \v k_{j -1},
    \v q_1, \dots, \v q_{j -1},
    \v a_1, \dots, \v a_{j -1}
    \}$
denote the vectors fixed by previous constraints in the ordering.
\begin{enumerate}
    \item if $dir_j = \For$
        \[
        \v a_j \notin \spn\big( \{
        \v k_1, \dots, \v k_{j -1},
        \v q_1, \dots, \v q_{j -1},
        \v a_1, \dots, \v a_{j -1},
        \} 
        \cup \{ \v k_j, \v q_j\}
        \cup \rows\left(\M\right)
        \big)
        \]
    \item if $dir_j = \Back$
        \[
        \v q_j \notin \spn\big( \{
        \v k_1, \dots, \v k_{j -1},
        \v q_1, \dots, \v q_{j -1},
        \v a_1, \dots, \v a_{j -1},
        \} 
        \cup \{ \v k_j, \v a_j\}
        \cup \rows\left(\M\right)
        \big)
        \]
\end{enumerate}
\end{enumerate}
\end{defn}

\begin{lemma}[Collision structure gives second preimages]
    If collision structure blabla exists for $\P = (\M, \C)$ then blabla with probability 1.
\end{lemma}

\pcb[mode=text]{$\mathsf{FindSecondPreimage}\Big(\Big)$}{
Compute $\vbase$ by executing $\PE(\vx)$  \\
... very similar
}
