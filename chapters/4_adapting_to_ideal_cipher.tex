\chapter{Adapting Linicrypt to the ideal cipher model}

In this chapter we modify the Linicrypt model to make use of the ideal cipher model instead of the random oracle model.
This means that a Linicrypt program gets access to a block cipher $\mathcal{E} = (E, D)$ where $E$ and $D$ are functions $\F \times \F \to \F$
instead of the hash function $\H : \{0,1\}^* \times \F^* \to \F$.
By the definition of a block cipher,
$\E_k := \E(k, \cdot)$ is a permutation of $\F$ for all $k \in \F$ and
$\D_k := \D(k, \cdot)$ is its inverse.
In the ideal cipher model, we assume that the block cipher has no weakness.
This is modeled by choosing each permutation $\E_k$ uniformly at random at the beginning of every security game.
We will call these programs with access to a block cipher instead of a hash function ideal cipher Linicrypt programs.

The command $y = \E(k, x)$ in an ideal cipher Linicrypt program has to be treated differently from the command $y = \H(k, x)$ when considering collision resistance,
because an attacker has access to the deterministic Linicrypt program and both directions of the block cipher $\mathcal{E} = (\E, \D)$.
Consider these two programs, $\PH$ in standard Linicrypt and $\PE$ in ideal cipher Linicrypt.

\begin{pchstack}[center,space=2cm]
  \pcbl[valign=c]{$\PH(k, x)$}{
    \pcreturn \H(k,x)
  }
  \pcbl[valign=c]{$\PE(k, x)$}{
    \pcreturn \E(k,x)
  }
\end{pchstack}
While $\PH$ is collision resistant, it is trivial to find second preimages for $\PE$
For any $k' \in \F$ the pair $(k', \D(k', \E(k, x)))$ is a second preimage to $(k,x)$.

This invertibility property of block ciphers has to be taken into account
in both the algebraic representation and the characterization of collision resistance.

\subsection{Algebraic representation for ideal cipher Linicrypt}

Parallel to standard Linicrypt, we will define the algebraic representation of an ideal cipher Linicrypt program.
Towards this goal we will make the equivalent definitions to the ones in chapter \ref{revisiting_algebraic_representations}.

\begin{defn}[Ideal cipher oracle constraint]
An \textbf{ideal cipher oracle constraint} of dimension $\base$ is a tuple $(\vk, \vx, \vy)$ for
$\vk, \vx$ and $\vy$ in $\F^{1 \times \base}$.
\end{defn}

We will just say ``constraint" to mean ideal cipher oracle constraint or random oracle constraint depending on the context.

\begin{defn}[Solution of constraints]
    Let $\C$ be a set of ideal cipher constraints of dimension $\base$.
    We say a vector $\vv \in \Base$ \textbf{solves} $\C$ if
    $\vy \vv = \E(\vk \vv, \vx \vv)$ for all $(\vk, \vx, \vy) \in \C$.
    Such a $\vv$ is also called a \textbf{solution} of $\C$.
    The set of all solutions to $\C$ is called $\sol(\C)$.
\end{defn}

Let $\P$ be an ideal cipher Linicrypt program.
Base variables and associated vectors are defined exactly as defined in standard Linicrypt.
The only difference is that base variables can now be instantiated with calls to the ideal cipher instead of calls to the random oracle.
For each command in $\P$ of the form $v_3 = \E(v_1,v_2)$
we define the \textbf{associated ideal cipher constraint} $(\vv_1, \vv_2, \vv_3)$.
Note, that the bold variant of the intermediate variable denotes its associated vector.
Correspondingly, each query to $\D$ of the form $v_3 = \D(v_1,v_2)$,
is associated with the constraint $(\vv_1, \vv_3, \vv_2)$.
We call the set of all associated constraints $\C$. 
The input matrix $\I$ and output matrix $\O$ are defined in the same way as in standard Linicrypt.
We call $(\I,\O,\C)$ the algebraic representation of $\P$.
Then, the following statement holds true, which is trivial direction of Corollary \ref{det_solvable_equiv} in standard Linicrypt.

\begin{lemma}
    Let $\P$ be an ideal cipher Linicrypt program with algebraic representation $(\I,\O,\C)$.
    Let $\vv$ denote the values of the base variables in an execution of $\P$ with input $(\dts i k)$ and output $(\dts o l)$.
    Then $\vv$ is a solution to $\C$ with $\I\vv = (\dts i k)$ and $\O\vv = (\dts o l)$
\end{lemma}

\begin{proof}
    The statements $\I\vv = (\dts i k)$ and $\O\vv = (\dts o l)$ follow from definition as in standard Linicrypt.
    Each constraint in $\C$ comes from a command in $\P$ with a query to the ideal cipher.

    Take some $(\vk, \vx, \vy) \in \C$.
    After renaming the intermediate variables of $\P$,
    it is associated either to the command $y = \E(k, x)$ or to the command $x = \D(k, y)$.
    In the first case we have $\vy\vv = y = \E(k, x) = \E(\vk\vv, \vx\vv)$.
    In the second case we also have $y = \E(k,x)$
    by the properties of the ideal cipher $\mathcal{E} = (\E,\D)$.
    Therefore $\vv$ is a solution to $\C$.
\end{proof}

The main definition that changes with ideal cipher Linicrypt is the one determining if $\C$ is deterministically solvable.
This definition captures the properties of the black box which $\P$ and an attacker can access.
In standard Linicrypt the black box is a one way random function.
In ideal cipher Linicrypt the black box is a random permutation which can be computed both ways,
as both the Linicrypt program and the attacker have full access to the ideal cipher $\mathcal{E} = (\E,\D)$.

To simplify the notation we extend the linear algebra operators $\rowsp$ and $\ker$
to be able to use them naturally with constraints and sets of constraints.
We define for a constraint $c = (\vk, \vx, \vy)$:
\begin{align*}
\rowsp(c) &= \rowsp(\vk) + \rowsp(\vx) + \rowsp(\vy) \\
\ker(c) &= \ker(\vk) \cap \ker(\vx) \cap \ker(\vy)
\end{align*}
For a set of constraints $\C$ we write:
\begin{align*}
\rowsp(\C) &= \sum_{c \, \in \, \C} \rowsp(c) \\
\ker(\C) &= \bigcap_{c \, \in \, \C} \ker(c)
\end{align*}

\begin{defn}[Deterministically Solvable]
\label{def_det_solvable_ic}
    Let $\C$ be a finite well-defined set of ideal cipher constraints of dimension $\base$,
    and let $\I \in \F^{k \times \base}$ for some $k \in \NN$.
    $\C$ is \textbf{deterministically solvable fixing} $\I$
    if there exists an ordering $(c_1, \dots, c_n)$ of $\C$
    such that for all $i=1, \dots, n$ the following holds.
    
    Let the components of $c_i$ be called $(\vk_i, \vx_i, \vy_i)$.
    One can write either
    % \vspace{-2mm}
    % \begin{equation*}
    % \textrm{(case a) } \Q_i = \m{\vk_i \\ \vx_i} \textrm{ and } \va_i = \vy_i 
    % \textrm{ or (case b) } \Q_i = \m{\vk_i \\ \vy_i} \textrm{ and } \va_i = \vx_i,
    % \end{equation*}
    \vspace{-4mm}
    \begin{center}
    $\Q_i = \m{\vk_i \\ \vx_i}$ and $\va_i = \vy_i$ (Case a) \,or\, 
    $\Q_i = \m{\vk_i \\ \vy_i}$ and $\va_i = \vx_i$ (Case b),
    \end{center}
    \vspace{-4mm}
    such that:
    
    % We destructure $c_i$ into $(\vk_i, \vx_i, \vy_i)$.
    % Then one can write either $\Q_i = \m{\vk_i \\ \vx_i}$ and $\va_i = \vy_i$ (case a)
    % or $\Q_i = \m{\vk_i \\ \vy_i}$ and $\va_i = \vx_i$ (case b) such that:
    \begin{enumerate}
    \item
        \label{solvable1_ic}
        $\rows(\Q_i) \subseteq \rowsp(\I) + \rowsp\big(\{\dts \va {i-1} \}\big)$
    \item
        \label{solvable2_ic}
        $\va_i \notin \rowsp(\I) + \rowsp\big(\{\dts \va {i-1} \}\big)$
    \end{enumerate}
    Additionally we require that $\rows(\I) \cup \{\va_1, \dots, \va_n\}$ form a basis of $\F^{1\times\base}$.
    We call $(c_1, \dots, c_n)$ a solution ordering of $\C$ fixing $\I$ (or fixing $\rows(\I)$).
\end{defn}

Note that the case distinction (Case a and Case b) is what models the invertibility of the ideal cipher.
It is actually an exclusive or,
because condition 1.~of Case a implies that condition 2.~of Case b is false.
With these definitions in place the Lemmas from section \ref{det_solvable_equiv} can be formulated in the same way.

\begin{lemma}
\label{alg_rep_det_solvable_ic}
    Let $(\I, \O, \C)$ be the algebraic representation of a deterministic ideal cipher Linicrypt program $\P$ taking $k$ inputs.
    Then $\C$ is deterministically solvable fixing $\I$.
\end{lemma}

\begin{sketch}
    For each constraint $c = (\vk, \vx, \vy)$ in $\C$ we set $\Q = \m{\vk^\top & \vx^\top}^\top$ and $\va = \vy$ if $c$ is associated to a call to $\E$.
    If $c$ is associated to a call to $\D$,
    we set $\Q = \m{\vk^\top & \vy^\top}^\top$ and $\va = \vx$.
    The rest of the proof is identical to the proof of Lemma \ref{alg_rep_det_solvable}.
\end{sketch}

\begin{lemma}
\label{is_algebraic_repr_ic}
    Let $\C$ be a finite well-defined set of ideal cipher constraints of dimension $\base$ with $|\C| = n$,
    let $\I = \m{\Id_k & 0} \in \F^{k\times\base}$ for $k = \base - n$
    and let $\O \in \F^{l \times \base}$ for some $l \in \NN$.
       
    $(\I, \O, \C)$ is the algebraic representation of a deterministic ideal cipher Linicrypt program $\P$
    if there exists an ordering $(c_1, \dots, c_n)$ of $\C$
    such that for all $i=1, \dots, n$ one of the following cases hold for $(\vk_i, \vx_i, \vy_i) = c_i$:
    \begin{enumerate}[label=(\alph*)]
    \item
    $\vy_i = \ve_{k+i}$ and $\{\vk_i, \vx_i\} \subseteq \spn(\dts \ve {k+i-1})$ or
    \item
    $\vx_i = \ve_{k+i}$ and $\{\vk_i, \vy_i\} \subseteq \spn(\dts \ve {k+i-1})$
    \end{enumerate}
\end{lemma}

\begin{sketch}
    The proof idea is the same as for Lemma \ref{is_algebraic_repr}.
    The $k$ inputs are handled as in standard Linicrypt.
    Consider the constraint $c_i$.
    If case (a) holds, then we convert this constraint into a command of the form $v_{k+i} = \E(q_1, q_2)$,
    for $q_1$ and $q_2$ being intermediate variables created by a linear combination.
    Then condition $\{\vk_i, \vx_i\} \subseteq \spn(\dts \ve {k+i-1})$ ensures that these linear combinations are well defined.
    As $\base = k + n$, all base variables have been set after $n$ query commands.
    We can use the rows of $\O$ to define the Linicrypt commands for the output variables.
\end{sketch}

\begin{lemma}
\label{det_solvable_lemma_ic}
    Let $\C$ be a set of deterministically solvable constraints fixing $\Inp \in \F^{k \times \base}$ for some $k \in \NN$.
    Let $\O \in \F^{\out \times \base}$ be an arbitrary output matrix for some $\out \in \NN$.
    Then there is a basis change $\B \in \F^{\base \times \base}$
    and a Linicrypt program $\P$,
    such that $(\Inp \B, \O \B, \C \B)$ is its algebraic representation.
\end{lemma}

\begin{sketch}
    By setting $\Q_i$ and $\va_i$ as in the definition \ref{def_det_solvable_ic} we can copy the proof of Lemma \ref{det_solvable_lemma}.
\end{sketch}

\begin{lemma}
\label{solution_space_bijection_ic}
    Let $\C$ be deterministically solvable fixing some $\I$.
    If we view $\I$ as a function $\Fsp \to \F^k$,
    then $\I|_{\sol(\C)}$ is a bijection.
\end{lemma}

\begin{sketch}
    By setting $\Q_i$ and $\va_i$ as in the definition \ref{def_det_solvable_ic} we can copy the proof of Lemma \ref{solution_space_bijection}.
\end{sketch}

\begin{corollary}
\label{det_solvable_computeable_ic}
    Let $\C$ be deterministically solvable fixing some $\I$.
    For each element in $\F^k$ its inverse under $\I|_{\sol(\C)}$ can be computed with $|\C|$ queries to the ideal cipher.
\end{corollary}

\begin{sketch}
    The proof is identical to the proof of Corollary \ref{det_solvable_computeable}.
\end{sketch}

\section{Collision Structure}

We have all the prerequisites to prove the analog of Lemma \ref{collision_structure_implies_attack}.
That is, we can give a sufficient condition for a program to be susceptible to a constant time second preimage attack.

\begin{prop}
\label{collision_structure_implies_attack_ic}
    Let $\P = (\I, \O, \C)$ be a deterministic ideal cipher Linicrypt program.
    Assume we can write $\C = \Ccs \sqcup \Cfix$ and
    $\Ccs$ is deterministically solvable fixing some $\Ics$ such that
    \begin{equation}
    \label{cs_condition_ic}
        \rowsp(\Ics) \supsetneq \rowsp(\O) + \rowsp(\Cfix).
    \end{equation}
    Then an attacker can find second preimages with $|\Ccs|$ queries.
    We say a program has a collision structure if it fulfills condition \eqref{cs_condition_ic}.
\end{prop}

Here we will give a more formal proof of this statement.
\begin{proof}
    The proof describes how to find a second preimage to some input $(\dts i k)$ to $\P$.
    By executing $\P$ on $(\dts i k)$ we compute the values of the base variables $\vv \in \sol(\C)$.
    Recall the bijection $\Ics|_{\sol(\Ccs)}: \sol(\Ccs) \to \F^{k'}$ where $k'$ is the number of rows of $\Ics$. 
    Instead of seeing this bijection as a map into the input space of $\P$ we will see it as a map into the quotient space
    $\sfrac{\Fsp}{\ker(\Ics)}$.
    This quotient space is defined by the equivalence relation $\vv \; \simcs \; \vw \iff \vv - \vw \in \ker(\Ics)$.
    We denote it by:
    \begin{align*}
    \widetilde\Ics: \sol(\Ccs) &\to \bigslant{\Fsp}{\ker(\Ics)} \\
    \vv &\mapsto [\vv]_\simcs
    \end{align*}
    
    Using condition \eqref{cs_condition_ic} we will map
    $\sfrac{\Fsp}{\ker(\Ics)}$ to $\sfrac{\Fsp}{\big(\ker(\O) \cap \ker(\Cfix)\big)}$
    non injectively.
    First we rewrite the condition \eqref{cs_condition_ic}:
    \begin{align}
    \eqref{cs_condition_ic} &\iff \ker(\Ics)^\top \supsetneq \ker(\O)^\top + \ker(\Cfix)^\top \\
    &\iff \ker(\Ics)^\top \supsetneq \big(\ker(\O) \cap \ker(\Cfix)\big)^\top \\
    \label{cs_kernel_ic}
    &\iff \ker(\Ics) \subsetneq \ker(\O) \cap \ker(\Cfix)
    \end{align}
    Let $\simfix$ denote the equivalence relation defining the quotient $\sfrac{\Fsp}{(\ker(\O) \cap \ker(\Cfix))}$.
    Consider the map
    \begin{align*}
        \lambda: \bigslant{\Fsp}{\ker(\Ics)} &\to \bigslant{\Fsp}{\big(\ker(\O) \cap \ker(\Cfix)\big)} \\
        [\vv]_{\simcs} &\mapsto [\vv]_{\sim_{fix}}.
    \end{align*}
    To show that it is well defined,
    we need to show that it is independent of the chosen representative.
    Let $[\vv]_\simcs = [\vw]_\simcs$ for arbitrary $\vv,\vw \in \Fsp$.
    By definition $\vv-\vw \in \ker(\Ics)$.
    Using $\eqref{cs_kernel_ic}$ we have $[\vv]_\simfix = [\vw]_\simfix$.
    Now we show that $\lambda$ is not injective.
    Let $\vw \in \ker(\O) \cap \ker(\Cfix)$ but $\vw \notin \ker(\Ics)$,
    so $[\vv + \vw]_\simcs \neq [\vv]_\simcs$.
    This is possible because by \eqref{cs_kernel_ic} $\ker(\Ics)$ is strictly smaller than $\ker(\O) \cap \ker(\Cfix)$.
    Then
    \[
        \lambda([\vv + \vw]_\simcs) = [\vv + \vw]_\simfix = [\vv]_\simfix = \lambda([\vv]_\simcs).
    \]
    As a consequence the concatenation $\lambda \circ \widetilde\Ics$ is not injective.
    Therefore we can find a $\vv' \in \sol(\Ccs)$ with $\vv' \neq \vv$ such that $[\vv']_\simfix = [\vv]_\simfix$.
    The latter is equivalent to $\O\vv' = \O\vv$ and $\vv' - \vv \in \ker(c)$ for all $c \in \Cfix$.
    As $\vv$ is a solution to $\Cfix$ it follows that $\vv'$ is a solution, too.
    Summing up, $\vv' \in \sol(\Ccs) \cap \sol(\Cfix) = \sol(\C)$ and $\vv' \neq \vv$.
    
    By the bijection argument we know that $\I\vv' \neq \I\vv$ and hence
    $\I\vv'$ is a second preimage to $\I\vv = (\dts i k)$.
    
    We argue why the second preimage is computable with $|\Ccs|$ queries.
    To compute such a $\vv'$ we need to compute preimages of $\lambda \circ \widetilde\Ics$.
    Because $\lambda$ is just a linear map, the space of preimages to any element in its image can be computed without any queries to $\H$.
    We can choose a preimage $[\vv']_\simcs$ to $[\vv]_\simfix$ from it's space of preimages arbitrarily while making sure that $[\vv']_\simcs \neq [\vv]_\simcs$.
    The inverse of the bijection $\widetilde\Ics$ is computable with $|\Ccs|$ queries by Corollary \ref{det_solvable_computeable_ic}.
\end{proof}

We give an example of a program which has a collision structure due to the invertibility of $\E$.

\begin{pchstack}[center, space=2cm]
    \pcbl[valign=c]{$\PE[col](a,b,c)$}{
        k_1 = c \\
        x_1 = b \\
        y_1 = \E(k_1, x_1) \\
        k_2 = a \\
        x_2 = y_1 \\
        y_2 = \E(k_2, x_2) \\
        \pcreturn y_1 + y_2
    }
    % \pseudocode[valign=c]{
    %     \O    = \> \begin{bmatrix}0 \> 0 \> 0 \> 1 \> 1\end{bmatrix} \\
    %     \vk_1 = \> \begin{bmatrix}0 \> 0 \> 1 \> 0 \> 0\end{bmatrix} \\
    %     \vx_1 = \> \begin{bmatrix}0 \> 1 \> 0 \> 0 \> 0\end{bmatrix} \\
    %     \vy_1 = \> \begin{bmatrix}0 \> 0 \> 0 \> 1 \> 0\end{bmatrix} \\
    %     \vk_2 = \> \begin{bmatrix}1 \> 0 \> 0 \> 0 \> 0\end{bmatrix} \\
    %     \vx_2 = \> \begin{bmatrix}0 \> 0 \> 0 \> 1 \> 0\end{bmatrix} \\
    %     \vy_2 = \> \begin{bmatrix}0 \> 0 \> 0 \> 0 \> 1\end{bmatrix} 
    % }
    \pcbm[valign=c]{Algebraic Representation}{
    % TODO fix matrix alignment
    \begin{pcmbox}
        \arraycolsep=3pt
        \begin{array}{r wl{3mm} l}
        \O    = \> \begin{bmatrix}0 \> 0 \> 0 \> 1 \> 1\end{bmatrix} \\[2pt]
        \vk_1 = \> \begin{bmatrix}0 \> 0 \> 1 \> 0 \> 0\end{bmatrix} \\[2pt]
        \vx_1 = \> \begin{bmatrix}0 \> 1 \> 0 \> 0 \> 0\end{bmatrix} \\[2pt]
        \vy_1 = \> \begin{bmatrix}0 \> 0 \> 0 \> 1 \> 0\end{bmatrix} \\[2pt]
        \vk_2 = \> \begin{bmatrix}1 \> 0 \> 0 \> 0 \> 0\end{bmatrix} \\[2pt]
        \vx_2 = \> \begin{bmatrix}0 \> 0 \> 0 \> 1 \> 0\end{bmatrix} \\[2pt]
        \vy_2 = \> \begin{bmatrix}0 \> 0 \> 0 \> 0 \> 1\end{bmatrix} 
        \end{array}
    \end{pcmbox}
    }
\end{pchstack}

We can set $\Ccs = \{c_1\}$, $\Cfix = \{c_2\}$ and $\Ics = \m{\O \\ \vk_2 \\ \vx_2 \\ \vk_1}$.

Then $\rowsp(\Ics) = \big( \rowsp(\O) + \rowsp(\Cfix) \big) \oplus \rowsp(\vk_1)$, so condition \eqref{cs_condition_ic} is fulfilled.
$\Ccs$ is deterministically solvable fixing $\Ics$.
We can set $\Q_1 = \m{\vk_1 \\ \vy_1}$ and $\va_1 = \vx_1$ and then we have: 
\begin{enumerate}
    \item $\rows(\Q_1) \subseteq \rowsp(\Ics)$
    \item $\va_1 \notin \rowsp(\Ics)$
\end{enumerate}

This makes Lemma \ref{collision_structure_implies_attack_ic} applicable and the Lemma describes how to construct an attack in the form of a Linicrypt program.

In plain language,
we can fix the output, set the second query and answer to the same values as for the given preimage and choose $k_1$ arbitrarily.
This determines the key $k_1$ and answer $y_1$ of the first query to $\E$, but not the query itself.
By using $\D$ we get the unique corresponding query $x_1$.
Then $(k_2, x_1, k_1)$ is a second preimage.

Now will work towards the converse of this statement.
That is we are trying to answer the question:
If $\P$ doesn't have a collision structure,
is it collision resistant?
We will confirm this for the case of a Linicrypt program which makes only a single query to the ideal cipher.

\begin{defn}
    A set of ideal cipher constraints $\C$ is called unsolvable fixing a space $\Fix \subseteq \Frowsp$ if for every ordering $(\dts c n)$ of $\C$,
    we have some $c_i = (\vk_i, \vx_i, \vy_i)$ such that both
    \begin{enumerate}
    \item    $\vy \in \Fix + \rowsp(\{\dts c {i-1}\}) + \rowsp(\{ \vk, \vx \})$ and
    \item    $\vx \in \Fix + \rowsp(\{\dts c {i-1}\}) + \rowsp(\{ \vk, \vy \})$.
    \end{enumerate}
\end{defn}

\begin{lemma}
\label{lemma_no_collision_structure}
    If $\P = (\I,\O,\C)$ does not have a collision structure,
    then for every split $\C = \Ccs \sqcup \Cfix$ we have one of the following:
    \begin{enumerate}
    \item $\Ccs$ is deterministically solvable fixing $\rowsp(\O) + \rowsp(\Cfix)$
    \item $\Ccs$ is is unsolvable fixing $\rowsp(\O) + \rowsp(\Cfix)$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Assume $\P$ does not have a collision structure.
    Let $\C = \Ccs \sqcup \Cfix$ be an arbitrary split of the set of constraints.
    Then for any matrix $\Ics$ with $\rowsp(\Ics) \supsetneq \rowsp(\O) + \rowsp(\Cfix)$ we have
    $\Ccs$ is not deterministically solvable fixing $\Ics$.
    We now assume condition \textit{2.}~from Lemma \ref{lemma_no_collision_structure} not true
    and show that this implies \textit{1.}~from Lemma \ref{lemma_no_collision_structure} is true.
    So we assume $\Ccs$ is not unsolvable fixing $\Fix = \rowsp(\O) + \rowsp(\Cfix)$.
    Then there is an ordering $(c_1, \dots, c_n)$ of $\Ccs$ such that for every $i$ we have
    $\vy \notin \Fix + \rowsp(\{\dts c {i-1}\}) + \rowsp(\{ \vk, \vx \})$ or
    $\vx \notin \Fix + \rowsp(\{\dts c {i-1}\}) + \rowsp(\{ \vk, \vy \})$.
    This gives the condition \textit{2.} of the definition of deterministically solvable.
    Therefore we can add some dimensions $\Fix$ and call it $\Fix' \supset \Fix$ such that
    $\Ccs$ is deterministically solvable fixing $\Fix'$.
    But if $\Fix' \supsetneq \Fix$ this would contradict the assumption that $\P$ does not have a collision structure.
    Therefore we know that $\Ccs$ is deterministically solvable fixing $\Fix = \rowsp(\O) + \rowsp(\Cfix)$.
\end{proof}

\begin{corollary}
\label{single_query_properties}
    Let $\P = (\I, \O, \C)$ be a program making only a single call to the ideal cipher.
    Then $\C = \{ (\vk, \vx, \vy)\}$ for some $\vk, \vx, \vy \in \Frowsp$.
    Assume $\P$ does not have a collision structure but there exists $\vv \neq \vv'$ in $\sol(\C)$ with $\O\vv = \O\vv'$.
    Then the following hold:
    \begin{enumerate}
    \item $\ker(\O) \cap \ker(\C) = \{0\}$
    \item $\vy \in \rowsp(\O) + \rowsp(\{\vk, \vx\})$
    \item $\vx \in \rowsp(\O) + \rowsp(\{\vk, \vy\})$
    \end{enumerate}
\end{corollary}
\begin{proof}
    If we set $\Ccs = \{\}$ then case \textit{2.} from Lemma \ref{lemma_no_collision_structure} cannot be true.
    Because $\{\}$ is deterministically solvable fixing $\rowsp(\O) + \rowsp(\C)$ we have a bijection between
    $\sol(\{\}) = \Fsp$ and $\rowsp(\O) + \rowsp(\C)$.
    Because $\rowsp(\O) = \ker(\O)^\perp$ and $\rowsp(\C) = \ker(\C)^\perp$
    this implies $\ker(\O) \cap \ker(\C) = \{0\}$.
    
    If we set $\Ccs = \C$ on the other hand,
    then case \textit{1.} from Lemma \ref{lemma_no_collision_structure} cannot be true.
    This is because if it was, then there wouldn't exists vectors $\vv \neq \vv'$ in $\sol(\C)$ with $\O\vv = \O\vv'$.
    Therefore $\C$ is unsolvable fixing $\rowsp(\O)$ which gives exactly 
    $\vy \in \rowsp(\O) + \rowsp(\{\vk, \vx\})$ and
    $\vx \in \rowsp(\O) + \rowsp(\{\vk, \vy\})$.
\end{proof}

\begin{prop}
\label{prop_single_query_cr_resistance}
    Let $\P = (\I, \O, \C)$ be a program making only a single call to the ideal cipher,
    i.e. $\C = \{ (\vk, \vx, \vy)\}$ for some $\vk, \vx, \vy \in \Frowsp$.
    Assume there is an adversary $\adv$ making $N$ queries to the ideal cipher winning the collision resistance security game with
    \[
        \prob{\mathsf{ColGame}(\P, \adv, \lambda) = 1 } > \frac{N(N-1)}{2(|\F| - N)}.
    \]
    Then $\P$ has a collision structure.
\end{prop}

This proof is based on the proofs of \cite[Lemma 10]{TCC:McQSwoRos19} and of \cite[Theorem 8.4 (Davies-Meyer)]{Boneh2015CourseIA}.

\begin{proof}
    Assume towards a contradiction that there is such an adversary $\A$ making $N$ queries
    and that $\P$ does not have a collision structure.
    % Without loss of generality we can assume that $\A$ has made the queries to the ideal cipher
    % can output the whole tuple of base variales $\vv$ and $\vv'$ for a collision. 
    We will work with the transcript between the adversary and the ideal cipher.
    Let $\mathcal{T}: \{1, \dots, N\} \to \F^3$ be the function defined by $\mathcal{T}(i) = (k, x, y)$,
    if the $i$th query of $\A$ is $\E(k, x)$ with response $y$ or if it is $\D(k, y)$ with response $x$.

    Let $\v i$ and $\v i'$ be the output of $\A$ in the event that it successfully found a collision.
    As $\C$ is deterministically solvable fixing $\I$, they correspond to unique vectors $\vv \neq \vv'$ in $\sol(\C)$.
    We can assume the adversary actually makes the queries corresponding to these inputs,
    i.e. $(\vk \vv, \vx \vv, \vy \vv)$ and $(\vk \vv', \vx \vv', \vy \vv')$ are contained in $\im(\mathcal{T})$.
    Otherwise, we can force $\A$ to make these queries by modifying it,
    so that it runs $\P(\v i)$ and $\P(\v i')$ as its last action.
    Let $i$ and $j$ be defined by $\mathcal{T}(i) = (\vk \vv, \vx \vv, \vy \vv)$
    and $\mathcal{T}(j) = (\vk \vv', \vx \vv', \vy \vv')$. 
    That is, at query $i$ the adversary has determined the values involved in the query for $\P(\v i)$ and
    at query $j$ it has determined the values involved in the query for $\P(\v i')$.
    
    Consider the case $i = j$.
    This means $\vv - \vv \in \ker(\C)$.
    By assumption $\v i$ and $\v i'$ are collisions, so $\vv - \vv' \in \ker(\O)$.
    Corollary \ref{single_query_properties} states $\ker(\O) \cap \ker(\C) = \{0\}$,
    so $\vv = \vv'$. 
    This is a contradiction to $\v i \neq \v i'$.
    
    Therefore we have $i \neq j$.
    By modifying $\A$ again,
    we can assume it outputs the value it fixes first as the first output, then $i < j$.
    Consider the point where $\A$ sent it's $j$th query and is waiting to receive the answer from the ideal cipher.
    If this query was to $\E$ we define $\Q = \m{\vk \\ \vx}$ and $\va = \vy$,
    otherwise we define $\Q = \m{\vk \\ \vy}$ and $\va = \vx$.
    
    Then we know from Corollary \ref{single_query_properties} that
    \begin{equation}
    \label{security_proof_equation}
    \va \in \rowsp(\O) + \rowsp(\Q) ,\quad \textrm{which means} \quad \va = \v \lambda \O + \v \gamma \Q.
    \end{equation}
    At query $j$ the vectors $\Q\vv, \va\vv, \Q\vv'$ and $\O(\vv' - \vv)$ are determined.
    The latter is $0$ by assumption that $\v i$ and $\v i'$ are a collision.
    Therefore we can use \eqref{security_proof_equation} to show
    \begin{equation*}
    \va (\vv' - \vv) = \v\lambda\O(\vv' - \vv) + \v\gamma \Q (\vv' - \vv),
    \end{equation*}
    which is equivalent to
    \begin{equation}
    \label{security_proof_equation2}
    \va \vv' = \va\vv + \v\gamma \Q \vv' - \v\gamma \Q\vv.
    \end{equation}
    All the vectors on the right of \eqref{security_proof_equation2} have been determined,
    while $\va\vv'$ is sampled uniformly from a set of size at least $|\F| - j + 1$.
    We call the event that this equation holds $Z_{i,j}$, then
    \[
        \prob{Z_{i,j}} = \frac{1}{|\F| - j + 1}.
    \]
    Using the union bound we have
    \begin{equation*}
    \prob{\mathsf{ColGame}(\P,\A,\lambda) = 1}
    \leq \sum_{j=1}^N \sum_{i=1}^{j-1} \prob{Z_{i,j}}
    \leq \sum_{j=1}^N \frac{j - 1}{|\F| - j + 1}
    \leq \frac{N(N-1)}{2(|\F| - N)},
    \end{equation*}
    which gives the contradiction.
\end{proof}

\begin{corollary}
\label{corollary_single_query_cr_resistance}
    Let $\P = (\I, \O, \C)$ be a program making only a single call to the ideal cipher.
    Then the following are equivalent:
    \begin{enumerate}
    \item $\P$ has a collision structure.
    \item There is an adversary making $2$ queries that always finds second preimages.
    \item There is an adversary making $N$ queries that finds collisions with probability $N(N-1) / 2(|\F| - N)$.
    \end{enumerate}
\end{corollary}

\section{Application: Compression schemes}
Outline
\begin{enumerate}
    \item Introduction to the 64 compression schemes 
    \item Trick with $v=0$ to model constants and why it is equivalent
    \item Model 64 compression schemes in Linicrypt
    \item Explain that the 12 secure schemes are the ones without a collision structure
\end{enumerate}

The papers \cite{C:BlaRogShr02} and \cite{C:PreGovVan93} have analyzed the 64 most basic constructions for a compression function
based on a single call to a block cipher $\BC = (\E, \D)$.
These compression schemes $f: \F \times \F \to \F$ are of the form $f(h, m) = \E(a, b) + c$ for $a,b,c \in \{h, m, h+m, v\}$.
Here $v \in \F$ is a fixed constant.
As these compression schemes are often used in the Merkle-Damg\aa rd construction,
one should think about $h$ as the chaining value and $m$ as the message block.
If not for the constant $v$, these constructions would be Linicrypt programs.
But as we will show, one can set $v=0$ without loss of generality.
Then Corollary \ref{corollary_single_query_cr_resistance} applies and it determines that 12 of these constructions are collision resistant.
This agrees with the results achieved by \cite{C:BlaRogShr02},
although they go further and identify 8 compression schemes that are not collision resistant,
but which become collision resistant when iterated as in the Merkle-Damg\aa rd construction.

First we argue why we can set $v=0$.
Assume that an adversary $\A$ can find collisions for some $f$ as described above, in the case that $v=0$.
If $a = 0$, then we can replace the block cipher $\E(\ddot, \ddot)$ by $\E(\ddot + v', \ddot)$ for some $v' \in \F$.
From the adversaries perspective this is still an ideal cipher,
so its success probability could not have been affected.
But this is equivalent to $\A$ being able to find collisions for the same compression scheme $f$ but with with the constant set to $v'$.
If $b=0$ we replace $\E$ with $\E(\ddot, \ddot + v')$ and if $c=0$ we replace it with $\E(\ddot, \ddot) + v'$.
Both of these modifications to an ideal cipher $\E$ yield another ideal cipher.

\subsection{The PGV compression schemes in Linicrypt}
We will give the algebraic representation the compression schemes described above.
First let us write them as an ideal cipher Linicrypt program. 

\begin{pchstack}[center,space=2cm]
    \pcbl[valign=c]{$\P(h,m)$}{
        y = \E(ch + dm, eh + fm) \\
        \pcreturn ah + bm + y
    }
    \pcbm[valign=c]{Algebraic Representation}{
    % TODO fix matrix alignment
    \begin{pcmbox}
        \arraycolsep=3pt
        \begin{array}{r wl{3mm} l}
            \O \>= \> \m{a&b&1} \\[2pt]
            \vk \>= \> \m{c&d&0} \\[2pt]
            \vx \>= \> \m{e&f&0} \\[2pt]
            \vy \>= \> \m{0&0&1}
        \end{array}
    \end{pcmbox}
    }
\end{pchstack}
The base variables are $\{h, m, y\}$ and for the algebraic representation we have ordered them as $(h, m, y)$.
The algebraic representation is $(\I, \O, \C)$ for $\I = \m{\Id_2 & 0}$ and $\C = \big\{(\vk, \vx, \vy) \big\}$.
$\P$ depends on the constants $a,b,c,d,e,f \in \{0,1\}$.
Each choice of these 6 binary constants corresponds to one of the compression schemes $f:\F \times \F \to \F$.
% For example, setting the variables as $(a,b,c,d,e,f) = (1,0,0,1,1,0)$ gives the Davies-Meyes compression scheme:
% $f(h,m) = \E(m,h) + h$.
% 
Using Lemma \ref{lemma_no_collision_structure} and Corollary \ref{corollary_single_query_cr_resistance},
one can derive that $\P$ is collision resistant if and only if
\begin{equation}
\label{eq_compression_secure}
    \m{a&b}, \m{c&d}, \m{e&f} \neq \m{0&0} \quad \textrm{and}\quad \m{a&b} \neq\m{c&d} \neq \m{e&f}.
\end{equation}
There are exactly 12 schemes fulfilling this condition,
which we list in Table \ref{table_12_secure_compression_schemes}.
The authors of \cite{C:BlaRogShr02} denote these as the group-1 schemes.

\begin{table}[h]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|l |c|c|c|c|c|c|l|}
    \hline
    $f(h,m)=$  & $a$ & $b$ & $c$ & $d$ & $e$ & $f$ & Name \\
    \hline
    $E(h,m)   +m$    & 0 & 1 & 1 & 0 & 0 & 1 & Matyas-Meyer-Oseas \\
    $E(h,h+m) +m$    & 0 & 1 & 1 & 0 & 1 & 1 &  \\
    $E(h+m,m) +m$    & 0 & 1 & 1 & 1 & 0 & 1 &  \\
    $E(h+m,h) +m$    & 0 & 1 & 1 & 1 & 1 & 0 &  \\
    $E(m,h)   +h$    & 1 & 0 & 0 & 1 & 1 & 0 & Davies-Meyer \\
    $E(m,h+m) +h$    & 1 & 0 & 0 & 1 & 1 & 1 &  \\
    $E(h+m,m) +h$    & 1 & 0 & 1 & 1 & 0 & 1 &  \\
    $E(h+m,h) +h$    & 1 & 0 & 1 & 1 & 1 & 0 &  \\
    $E(m,h)   +h+m$  & 1 & 1 & 0 & 1 & 1 & 0 &  \\
    $E(m,h+m) +h+m$  & 1 & 1 & 0 & 1 & 1 & 1 &  \\
    $E(h,m)   +h+m$  & 1 & 1 & 1 & 0 & 0 & 1 & Miyaguchi-Preneel \\
    $E(h,h+m) +h+m$  & 1 & 1 & 1 & 0 & 1 & 1 &  \\
    \hline
\end{tabular}
\caption{Parameters for the 12 secure compression schemes according to \eqref{eq_compression_secure}}.
\label{table_12_secure_compression_schemes}
\end{table}
