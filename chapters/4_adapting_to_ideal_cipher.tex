\chapter{Adapting the Linicrypt model to the ideal cipher model}

In this chapter we modify the Linicrypt model to make use of the ideal cipher model instead of the random oracle model.
This means that a Linicrypt program gets access to a block cipher $\mathcal{E} = (E, D)$ where $E$ and $D$ are functions $\F \times \F \to \F$
instead of the hash function $\H : \{0,1\}^* \times \F^* \to \F$.
By the definition of a block cipher,
$\E_k := \E(k, \cdot)$ is a permutation of $\F$ for all $k \in \F$ and
$\D_k := \D(k, \cdot)$ is its inverse.
In the ideal cipher model, we assume that the block cipher has no weakness.
This is modeled by choosing each permutation $\E_k$ uniformly at random at the beginning of every security game.
We will call these programs with access to a block cipher instead of a hash function ideal cipher Linicrypt programs.

The command $y = \E(k, x)$ in an ideal cipher Linicrypt program has to be treated differently from the command $y = \H(k, x)$ when considering collision resistance,
because an attacker has access to the deterministic Linicrypt program and both directions of the block cipher $\mathcal{E} = (\E, \D)$.
Consider these two programs, $\PH$ in standard Linicrypt and $\PE$ in ideal cipher Linicrypt.

\begin{pchstack}[center,space=2cm]
  \pcbl[valign=c]{$\PH(k, x)$}{
    \pcreturn \H(k,x)
  }
  \pcbl[valign=c]{$\PE(k, x)$}{
    \pcreturn \E(k,x)
  }
\end{pchstack}
While $\PH$ is collision resistant, it is trivial to find second preimages for $\PE$
For any $k' \in \F$ the pair $(k', \D(k', \E(k, x)))$ is a second preimage to $(k,x)$.

This invertibility property of block ciphers has to be taken into account
in both the algebraic representation and the characterization of collision resistance.

\subsection{Algebraic representation for ideal cipher Linicrypt}

Parallel to standard Linicrypt, we will define the algebraic representation of an ideal cipher Linicrypt program.
Towards this goal we will make the equivalent definitions to the ones in chapter \ref{revisiting_algebraic_representations}.

\begin{defn}[Ideal cipher oracle constraint]
An \textbf{ideal cipher oracle constraint} of dimension $\base$ is a tuple $(\vk, \vx, \vy)$ for
$\vk, \vx$ and $\vy$ in $\F^{1 \times \base}$.
\end{defn}

We will just say ``constraint" to mean ideal cipher oracle constraint or random oracle constraint depending on the context.

\begin{defn}[Solution of constraints]
    Let $\C$ be a set of ideal cipher constraints of dimension $\base$.
    We say a vector $\vv \in \Base$ \textbf{solves} $\C$ if
    $\vy \vv = \E(\vk \vv, \vx \vv)$ for all $(\vk, \vx, \vy) \in \C$.
    Such a $\vv$ is also called a \textbf{solution} of $\C$.
    The set of all solutions to $\C$ is called $\sol(\C)$.
\end{defn}

Let $\P$ be an ideal cipher Linicrypt program.
Base variables and associated vectors are defined exactly as defined in standard Linicrypt.
The only difference is that base variables can now be instantiated with calls to the ideal cipher instead of calls to the random oracle.
For each command in $\P$ of the form $v_3 = \E(v_1,v_2)$
we define the \textbf{associated ideal cipher constraint} $(\vv_1, \vv_2, \vv_3)$.
Note, that the bold variant of the intermediate variable denotes its associated vector.
Correspondingly, each query to $\D$ of the form $v_3 = \D(v_1,v_2)$,
is associated with the constraint $(\vv_1, \vv_3, \vv_2)$.
We call the set of all associated constraints $\C$. 
The input matrix $\I$ and output matrix $\O$ are defined in the same way as in standard Linicrypt.
We call $(\I,\O,\C)$ the algebraic representation of $\P$.
Then, the following statement holds true, which is trivial direction of Corollary \ref{det_solvable_equiv} in standard Linicrypt.

\begin{lemma}
    Let $\P$ be an ideal cipher Linicrypt program with algebraic representation $(\I,\O,\C)$.
    Let $\vv$ denote the values of the base variables in an execution of $\P$ with input $(\dts i k)$ and output $(\dts o l)$.
    Then $\vv$ is a solution to $\C$ with $\I\vv = (\dts i k)$ and $\O\vv = (\dts o l)$
\end{lemma}

\begin{proof}
    The statements $\I\vv = (\dts i k)$ and $\O\vv = (\dts o l)$ follow from definition as in standard Linicrypt.
    Each constraint in $\C$ comes from a command in $\P$ with a query to the ideal cipher.

    Take some $(\vk, \vx, \vy) \in \C$.
    After renaming the intermediate variables of $\P$,
    it is associated either to the command $y = \E(k, x)$ or to the command $x = \D(k, y)$.
    In the first case we have $\vy\vv = y = \E(k, x) = \E(\vk\vv, \vx\vv)$.
    In the second case we also have $y = \E(k,x)$
    by the properties of the ideal cipher $\mathcal{E} = (\E,\D)$.
    Therefore $\vv$ is a solution to $\C$.
\end{proof}

The main definition that changes with ideal cipher Linicrypt is the one determining if $\C$ is deterministically solvable.
This definition captures the properties of the black box which $\P$ and an attacker can access.
In standard Linicrypt the black box is a one way random function.
In ideal cipher Linicrypt the black box is a random permutation which can be computed both ways,
as both the Linicrypt program and the attacker have full access to the ideal cipher $\mathcal{E} = (\E,\D)$.

To simplify the notation we extend the linear algebra operators $\rowsp$ and $\ker$
to be able to use them naturally with constraints and sets of constraints.
We define for a constraint $c = (\vk, \vx, \vy)$:
\begin{align*}
\rowsp(c) &= \rowsp(\vk) + \rowsp(\vx) + \rowsp(\vy) \\
\ker(c) &= \ker(\vk) \cap \ker(\vx) \cap \ker(\vy)
\end{align*}
For a set of constraints $\C$ we write:
\begin{align*}
\rowsp(\C) &= \sum_{c \, \in \, \C} \rowsp(c) \\
\ker(\C) &= \bigcap_{c \, \in \, \C} \ker(c)
\end{align*}

\begin{defn}[Deterministically Solvable]
\label{def_det_solvable_ic}
    Let $\C$ be a finite well-defined set of ideal cipher constraints of dimension $\base$,
    and let $\I \in \F^{k \times \base}$ for some $k \in \NN$.
    $\C$ is \textbf{deterministically solvable fixing} $\I$
    if there exists an ordering $(c_1, \dots, c_n)$ of $\C$
    such that for all $i=1, \dots, n$ the following holds.
    
    Let the components of $c_i$ be called $(\vk_i, \vx_i, \vy_i)$.
    One can write either
    % \vspace{-2mm}
    % \begin{equation*}
    % \textrm{(case a) } \Q_i = \m{\vk_i \\ \vx_i} \textrm{ and } \va_i = \vy_i 
    % \textrm{ or (case b) } \Q_i = \m{\vk_i \\ \vy_i} \textrm{ and } \va_i = \vx_i,
    % \end{equation*}
    \vspace{-4mm}
    \begin{center}
    $\Q_i = \m{\vk_i \\ \vx_i}$ and $\va_i = \vy_i$ (Case a) \,or\, 
    $\Q_i = \m{\vk_i \\ \vy_i}$ and $\va_i = \vx_i$ (Case b),
    \end{center}
    \vspace{-4mm}
    such that:
    
    % We destructure $c_i$ into $(\vk_i, \vx_i, \vy_i)$.
    % Then one can write either $\Q_i = \m{\vk_i \\ \vx_i}$ and $\va_i = \vy_i$ (case a)
    % or $\Q_i = \m{\vk_i \\ \vy_i}$ and $\va_i = \vx_i$ (case b) such that:
    \begin{enumerate}
    \item
        \label{solvable1_ic}
        $\rows(\Q_i) \subseteq \rowsp(\I) + \rowsp\big(\{c_1, \dots, c_{i-1}\}\big)$
    \item
        \label{solvable2_ic}
        $\va_i \notin \rowsp(\I) + \rowsp\big(\{c_1, \dots, c_{i-1}\}\big)$
    \end{enumerate}
    Additionally we require that $\rows(\I) \cup \{\va_1, \dots, \va_n\}$ form a basis of $\F^{1\times\base}$.
    We call $(c_1, \dots, c_n)$ a solution ordering of $\C$ fixing $\I$ (or fixing $\rows(\I)$).
\end{defn}

Note that the case distinction (Case a and Case b) is what models the invertibility of the ideal cipher.
It is actually an exclusive or,
because condition 1.~of Case a implies that condition 2.~of Case b is false.
With these definitions in place the Lemmas from section \ref{det_solvable_equiv} can be formulated in the same way.

\begin{lemma}
\label{alg_rep_det_solvable_ic}
    Let $(\I, \O, \C)$ be the algebraic representation of a deterministic ideal cipher Linicrypt program $\P$ taking $k$ inputs.
    Then $\C$ is deterministically solvable fixing $\I$.
\end{lemma}

\begin{sketch}
    For each constraint $c = (\vk, \vx, \vy)$ in $\C$ we set $\Q = \m{\vk^\top & \vx^\top}^\top$ and $\va = \vy$ if $c$ is associated to a call to $\E$.
    If $c$ is associated to a call to $\D$,
    we set $\Q = \m{\vk^\top & \vy^\top}^\top$ and $\va = \vx$.
    The rest of the proof is identical to the proof of Lemma \ref{alg_rep_det_solvable}.
\end{sketch}

\begin{lemma}
\label{is_algebraic_repr_ic}
    Let $\C$ be a finite well-defined set of ideal cipher constraints of dimension $\base$ with $|\C| = n$,
    let $\I = \m{\Id_k & 0} \in \F^{k\times\base}$ for $k = \base - n$
    and let $\O \in \F^{l \times \base}$ for some $l \in \NN$.
       
    $(\I, \O, \C)$ is the algebraic representation of a deterministic ideal cipher Linicrypt program $\P$
    if there exists an ordering $(c_1, \dots, c_n)$ of $\C$
    such that for all $i=1, \dots, n$ one of the following cases hold for $(\vk_i, \vx_i, \vy_i) = c_i$:
    \begin{enumerate}[label=(\alph*)]
    \item
    $\vy_i = \ve_{k+i}$ and $\{\vk_i, \vx_i\} \subseteq \spn(\dts \ve {k+i-1})$ or
    \item
    $\vx_i = \ve_{k+i}$ and $\{\vk_i, \vy_i\} \subseteq \spn(\dts \ve {k+i-1})$
    \end{enumerate}
\end{lemma}

\begin{sketch}
    The proof idea is the same as for Lemma \ref{is_algebraic_repr}.
    The $k$ inputs are handled as in standard Linicrypt.
    Consider the constraint $c_i$.
    If case (a) holds, then we convert this constraint into a command of the form $v_{k+i} = \E(q_1, q_2)$,
    for $q_1$ and $q_2$ being intermediate variables created by a linear combination.
    Then condition $\{\vk_i, \vx_i\} \subseteq \spn(\dts \ve {k+i-1})$ ensures that these linear combinations are well defined.
    As $\base = k + n$, all base variables have been set after $n$ query commands.
    We can use the rows of $\O$ to define the Linicrypt commands for the output variables.
\end{sketch}

\begin{lemma}
\label{det_solvable_lemma_ic}
    Let $\C$ be a set of deterministically solvable constraints fixing $\Inp \in \F^{k \times \base}$ for some $k \in \NN$.
    Let $\O \in \F^{\out \times \base}$ be an arbitrary output matrix for some $\out \in \NN$.
    Then there is a basis change $\B \in \F^{\base \times \base}$
    and a Linicrypt program $\P$,
    such that $(\Inp \B, \O \B, \C \B)$ is its algebraic representation.
\end{lemma}

\begin{sketch}
    By setting $\Q_i$ and $\va_i$ as in the definition \ref{def_det_solvable_ic} we can copy the proof of Lemma \ref{det_solvable_lemma}.
\end{sketch}

\begin{lemma}
\label{solution_space_bijection_ic}
    Let $\C$ be deterministically solvable fixing some $\I$.
    If we view $\I$ as a function $\Fsp \to \F^k$,
    then $\I|_{\sol(\C)}$ is a bijection.
\end{lemma}

\begin{sketch}
    By setting $\Q_i$ and $\va_i$ as in the definition \ref{def_det_solvable_ic} we can copy the proof of Lemma \ref{solution_space_bijection}.
\end{sketch}

\begin{corollary}
\label{det_solvable_computeable_ic}
    Let $\C$ be deterministically solvable fixing some $\I$.
    For each element in $\F^k$ its inverse under $\I|_{\sol(\C)}$ can be computed with $|\C|$ queries to the ideal cipher.
\end{corollary}

\begin{sketch}
    The proof is identical to the proof of Corollary \ref{det_solvable_computeable}.
\end{sketch}

\section{Collision Structure}

We have all the prerequisites to prove the analog of Lemma \ref{collision_structure_implies_attack}.
That is, we can give a sufficient condition for a program to be susceptible to a constant time second preimage attack.

\begin{lemma}
\label{collision_structure_implies_attack_ic}
    Let $\P = (\I, \O, \C)$ be a deterministic ideal cipher Linicrypt program.
    Assume we can write $\C = \Ccs \cup \Cfix$ and
    $\Ccs$ is deterministically solvable fixing some $\Ics$ such that
    \begin{equation}
    \label{cs_condition_ic}
        \rowsp(\Ics) \supsetneq \rowsp(\O) + \rowsp(\Cfix).
    \end{equation}
    Then an attacker can find second preimages with $|\Ccs|$ queries.
    We say a program has a collision structure if it fulfills condition \eqref{cs_condition_ic}.
\end{lemma}

Here we will give a more formal proof of this statement.
\begin{proof}
    The proof describes how to find a second preimage to some input $(\dts i k)$ to $\P$.
    By executing $\P$ on $(\dts i k)$ we compute the values of the base variables $\vv \in \sol(\C)$.
    Recall the bijection $\Ics|_{\sol(\Ccs)}: \sol(\Ccs) \to \F^{k'}$ where $k'$ is the number of rows of $\Ics$. 
    Instead of seeing this bijection as a map into the input space of $\P$ we will see it as a map into the quotient space
    $\sfrac{\Fsp}{\ker(\Ics)}$.
    This quotient space is defined by the equivalence relation $\vv \; \simcs \; \vw \iff \vv - \vw \in \ker(\Ics)$.
    We denote it by:
    \begin{align*}
    \widetilde\Ics: \sol(\Ccs) &\to \bigslant{\Fsp}{\ker(\Ics)} \\
    \vv &\mapsto [\vv]_\simcs
    \end{align*}
    
    Using condition \eqref{cs_condition_ic} we will map
    $\sfrac{\Fsp}{\ker(\Ics)}$ to $\sfrac{\Fsp}{\big(\ker(\O) \cap \ker(\Cfix)\big)}$
    non injectively.
    First we rewrite the condition \eqref{cs_condition_ic}:
    \begin{align}
    \eqref{cs_condition_ic} &\iff \ker(\Ics)^\top \supsetneq \ker(\O)^\top + \ker(\Cfix)^\top \\
    &\iff \ker(\Ics)^\top \supsetneq \big(\ker(\O) \cap \ker(\Cfix)\big)^\top \\
    \label{cs_kernel_ic}
    &\iff \ker(\Ics) \subsetneq \ker(\O) \cap \ker(\Cfix)
    \end{align}
    Let $\simfix$ denote the equivalence relation defining the quotient $\sfrac{\Fsp}{(\ker(\O) \cap \ker(\Cfix))}$.
    Consider the map
    \begin{align*}
        \lambda: \bigslant{\Fsp}{\ker(\Ics)} &\to \bigslant{\Fsp}{\big(\ker(\O) \cap \ker(\Cfix)\big)} \\
        [\vv]_{\simcs} &\mapsto [\vv]_{\sim_{fix}}.
    \end{align*}
    To show that it is well defined,
    we need to show that it is independent of the chosen representative.
    Let $[\vv]_\simcs = [\vw]_\simcs$ for arbitrary $\vv,\vw \in \Fsp$.
    By definition $\vv-\vw \in \ker(\Ics)$.
    Using $\eqref{cs_kernel_ic}$ we have $[\vv]_\simfix = [\vw]_\simfix$.
    Now we show that $\lambda$ is not injective.
    Let $\vw \in \ker(\O) \cap \ker(\Cfix)$ but $\vw \notin \ker(\Ics)$,
    so $[\vv + \vw]_\simcs \neq [\vv]_\simcs$.
    This is possible because by \eqref{cs_kernel_ic} $\ker(\Ics)$ is strictly smaller than $\ker(\O) \cap \ker(\Cfix)$.
    Then
    \[
        \lambda([\vv + \vw]_\simcs) = [\vv + \vw]_\simfix = [\vv]_\simfix = \lambda([\vv]_\simcs).
    \]
    As a consequence the concatenation $\lambda \circ \widetilde\Ics$ is not injective.
    Therefore we can find a $\vv' \in \sol(\Ccs)$ with $\vv' \neq \vv$ such that $[\vv']_\simfix = [\vv]_\simfix$.
    The latter is equivalent to $\O\vv' = \O\vv$ and $\vv' - \vv \in \ker(c)$ for all $c \in \Cfix$.
    As $\vv$ is a solution to $\Cfix$ it follows that $\vv'$ is a solution, too.
    Summing up, $\vv' \in \sol(\Ccs) \cap \sol(\Cfix) = \sol(\C)$ and $\vv' \neq \vv$.
    
    By the bijection argument we know that $\I\vv' \neq \I\vv$ and hence
    $\I\vv'$ is a second preimage to $\I\vv = (\dts i k)$.
    
    We argue why the second preimage is computable with $|\Ccs|$ queries.
    To compute such a $\vv'$ we need to compute preimages of $\lambda \circ \widetilde\Ics$.
    Because $\lambda$ is just a linear map, the space of preimages to any element in its image can be computed without any queries to $\H$.
    We can choose a preimage $[\vv']_\simcs$ to $[\vv]_\simfix$ from it's space of preimages arbitrarily while making sure that $[\vv']_\simcs \neq [\vv]_\simcs$.
    The inverse of the bijection $\widetilde\Ics$ is computable with $|\Ccs|$ queries by Corollary \ref{det_solvable_computeable_ic}.
\end{proof}

We give an example of a program which has a collision structure due to the invertibility of $\E$.

\begin{pchstack}[center, space=2cm]
    \pcbl[valign=c]{$\PE[col](a,b,c)$}{
        k_1 = c \\
        x_1 = b \\
        y_1 = \E(k_1, x_1) \\
        k_2 = a \\
        x_2 = y_1 \\
        y_2 = \E(k_2, x_2) \\
        \pcreturn y_1 + y_2
    }
    \pseudocode[valign=c]{
        \O    = \> \begin{bmatrix}0 \> 0 \> 0 \> 1 \> 1\end{bmatrix} \\
        \vk_1 = \> \begin{bmatrix}0 \> 0 \> 1 \> 0 \> 0\end{bmatrix} \\
        \vx_1 = \> \begin{bmatrix}0 \> 1 \> 0 \> 0 \> 0\end{bmatrix} \\
        \vy_1 = \> \begin{bmatrix}0 \> 0 \> 0 \> 1 \> 0\end{bmatrix} \\
        \vk_2 = \> \begin{bmatrix}1 \> 0 \> 0 \> 0 \> 0\end{bmatrix} \\
        \vx_2 = \> \begin{bmatrix}0 \> 0 \> 0 \> 1 \> 0\end{bmatrix} \\
        \vy_2 = \> \begin{bmatrix}0 \> 0 \> 0 \> 0 \> 1\end{bmatrix} 
    }
\end{pchstack}

We can set $\Ccs = \{c_1\}$, $\Cfix = \{c_2\}$ and $\Ics = \m{\O \\ \vk_2 \\ \vx_2 \\ \vk_1}$.

Then $\rowsp(\Ics) = \big( \rowsp(\O) + \rowsp(\Cfix) \big) \oplus \rowsp(\vk_1)$, so condition \eqref{cs_condition_ic} is fulfilled.
$\Ccs$ is deterministically solvable fixing $\Ics$.
We can set $\Q_1 = \m{\vk_1 \\ \vy_1}$ and $\va_1 = \vx_1$ and then we have: 
\begin{enumerate}
    \item $\rows(\Q_1) \subseteq \rowsp(\Ics)$
    \item $\va_1 \notin \rowsp(\Ics)$
\end{enumerate}

In other words,
we can fix the output, set the second query and anser to the same values as for the given preimage and choose $k_1$ arbitrarily.
This determines the key and answer $y_1$ to the first query to $\E$, but not the query itself.
By using $\D$ we get the correct query $x_1$.
Then $(k_2, x_1, k_1)$ are a second preimage.


%%%%%%%%%%%%%%%%%%%%% OLD %%%%%%%%%%%%%%%%%%%%%%

\section{Collision Structure old}

To explain the concept of a collision structure, we will make use of an example.
Consider the following Linicrypt program:
\pcb[valign=c]{$\PE[col,1](a,b,c)$}{
    w = E(c, b+c) + a \\
    \pcreturn c + \E(w,b)
}
A second preimage to $(a,b,c)$ can be found by the following procedure:
Choose some $w' \neq w$.
It will turn out, that even choosing $w'$ at random,
one can calculate what the other base variables need to be such that the output stays the same.
As we want $c + \E(w,b) = c' + \E(w', b')$ we can again choose any $b'$ and compute $c'$. 
Finally, we can compute $a'$ from the equation $w' = \E(c', c' + b') + a'$

One can more easily see that such a procedure is possible by looking at the algebraic representation of $\PE[col,1]$.
In order to highlight which are the base variables, we rewrite the program a bit more explicitly.
\pcb[valign=c]{$\PE[col,1](a,b,c)$}{
    k_1 = c \\
    x_1 = b+c \\
    y_1 = \E(k_1, x_1) \\
    k_2 = y_1 + a \\
    x_2 = b \\
    y_2 = \E(k_2, x_2) \\
    \pcreturn c + y_2
}
The base variables are $(a, b, c, y_1, y_2)$ and the algebraic representation is
\[
    \O = \begin{bmatrix} 0, 0, 1, 0, 1 \end{bmatrix} 
        \qquad \C = \{(\E, \v k_1, \v x_1, \v y_1), (\E, \v k_2, \v x_2, \v y_2)\}
\]
where
\begin{align*}
\v k_1 &= \begin{bmatrix} 0, 0, 1, 0, 0 \end{bmatrix} \\
\v x_1 &= \begin{bmatrix} 0, 1, 1, 0, 0 \end{bmatrix} \\
\v y_1 &= \begin{bmatrix} 0, 0, 0, 1, 0 \end{bmatrix} \\
\v k_2 &= \begin{bmatrix} 1, 0, 0, 1, 0 \end{bmatrix} \\
\v x_2 &= \begin{bmatrix} 0, 1, 0, 0, 0 \end{bmatrix} \\
\v y_2 &= \begin{bmatrix} 0, 0, 0, 0, 1 \end{bmatrix}.
\end{align*}

We can formulate the previous attack from in terms of the algebraic representation.
The task is to find a $\v v_\base' = [a', b', c', y_1', y_2'] \neq \v v_\base$ such that:
\begin{align}
\label{constraint_output}
\PE[col,1](a', b', c') = \O \vbase' &= \O \vbase = \PE[col,1](a,b,c) \\
\label{constraint_cipher_1}
y_1' = \vy_i \vbase' &=  \E(\vk_1 \vbase'\,, \; \vx_1 \vbase')\\
\label{constraint_cipher_2}
y_2' = \vy_i \vbase' &=  \E(\vk_2 \vbase'\,, \; \vx_2 \vbase')
\end{align}

We can fulfill these requirements step by step.
First, we constrain $\vbase'$ by requiring 
\[
    \O \vbase' = \O \vbase.
\]
This reduces the dimension of the space of possible solutions for $\vbase'$ to 4,
as $\O \vbase$ is in the range of $\O$ by definition.
Now note, that neither $\vk_2$ nor $\vx_2$ are in the span of $\rows(\O)$.
Therefore we can choose $k_2'$ and $x_2'$ at random such that $(k_2', x_2') \neq (k_2, x_2)$,
and constrain $\vbase'$ by requiring
\[
    \vk_2 \vbase' = k_2' \quad \textrm{and} \quad \vx_2 \vbase' = x_2'.
\]
Now we can compute $y_2' = \E(k_2', x_2')$ and add constraint \eqref{constraint_cipher_2}.
This constraint is compatible with the previous constraints because $\vy_2$ is not in the span of
$\rows(\O) \cup \{\vk_2, \vx_2\}$.
The dimension of the subspace of solutions is now 1, as we have added 4 one-dimensional constraints.

Now one only needs to fulfill constraint \eqref{constraint_cipher_1}.
As $\vk_1$ and $\vx_1$ are in the span of
$\rows(\O) \cup \{\vk_2, \vx_2, \vy_2\}$ the intermediate variables $k_1'$ and $x_1'$ are uniquely determined.
E.g. $\vk_1 = \O - \vy_2$ and therefore $k_1' = \PE[col,1](a,b,c) - y_2'$.

Finally, note that 
$\vy_1 \notin \spn\big( \rows(\O) \cup \{ \vk_2, \vx_2, \vy_2 \} \cup \{ \vk_1, \vx_1 \} \big)$.
Therefore, adding the constraint
\[
    \vy_1 \vbase' = y_1' = \E(k_1', x_1')
\]
reduces the solution space of possible $\vbase'$ to a single point in $\Base$.
We know that $\vbase' \neq \vbase$ because $(k_2, x_2') \neq (k_2, x_2)$.
The only way to produce different intermediate variables in a deterministic program is to choose different input,
hence $(a',b',c') \neq (a,b,c)$.

This example would have worked exactly the same if we replaced $\E$ with $\H$.
What follows is an example where the invertibility property of $\E_k$ plays a role.

\begin{pchstack}[center, space=2cm]
    \pcbl[valign=c]{$\PE[col,2](a,b,c)$}{
        k_1 = c \\
        x_1 = b \\
        y_1 = \E(k_1, x_1) \\
        k_2 = a \\
        x_2 = y_1 \\
        y_2 = \E(k_2, x_2) \\
        \pcreturn y_1 + y_2
    }
    \pseudocode[valign=c]{
        \O    = \begin{bmatrix}0,0,0,1,1\end{bmatrix} \\
        \vk_1 = \begin{bmatrix}0,0,1,0,0\end{bmatrix} \\
        \vx_1 = \begin{bmatrix}0,1,0,0,0\end{bmatrix} \\
        \vy_1 = \begin{bmatrix}0,0,0,1,0\end{bmatrix} \\
        \vk_2 = \begin{bmatrix}1,0,0,0,0\end{bmatrix} \\
        \vx_2 = \begin{bmatrix}0,0,0,1,0\end{bmatrix} \\
        \vy_2 = \begin{bmatrix}0,0,0,0,1\end{bmatrix} 
    }
\end{pchstack}
For this program there is a similar procedure to find second preimages.
As before, the first constraint is $\O $
In this case we can fix $\vk_2 \vbase' = k_2' = k_2$, $\vx_2 \vbase' = x_2' = x_2$ and $\vy_2 \vbase' = y_2' = y_2$.
Therefore condition \eqref{constraint_cipher_2} is fulfilled trivially.
After adding these 4 constraints the solutions space is still 1-dimensional.
Note, that $\vy_1 = \vx_2$ and it is therefore already fixed at this point,
hence to fulfill \eqref{constraint_cipher_1} we have to make use of the invertibility property of $\E_k$.
Because
\begin{align*}
    \vy_1 \vbase' &= \E(\vk_1 \vbase', \vx_1 \vbase') \\
    \iff \vx_1 \vbase' &= \D(\vk_1 \vbase', \vy_1 \vbase'),
\end{align*}
we can choose a random $k_1' \neq k_1$ and compute $x_1' = \D(k_1', y_1')$ in order to fulfill (3.1).
With this fifth constraint we have found a single $\vbase' \neq \vbase$.

We want to briefly summarize the conditions for this kind of second preimage attack.
Let $\P'$ denote the execution of 
\begin{itemize}
\item
    Some ideal cipher constraints are fulfilled by setting the intermediate variables in $\P(a',b',c')$ to the same value as in $\P(a,b,c)$ 
\item
    There is some constraint for which either the input or the output is undetermined by the previously fixed intermediate variables
\item
    For this constraint and all following constraint one can iteratively call the ideal cipher $\BC$ to set the intermediate variables such that the constraints are fulfilled.
    This is only possible, if the either the output or the input is undetermined by previously fixed variables.
\end{itemize}


\begin{defn}[Collision structure]
Let $\P = (\O, \C)$ be a Linicrypt program with $|\C| = n$.
A \textbf{collision structure} for $\P$ is an index $1 \leq i^* \leq n$, an ordering $(c_1, \dots, c_n)$ of $\C$ for $c_i = (Op_i, \v k_i, \v q_i,\v a_i)$
and a tuple $(dir_{i^*}, \dots, dir_n)$ for $dir_i \in \{\For, \Back\}$,
such that the following two conditions hold:
\begin{enumerate}
\item 
Let $\mathcal{F}_\is = \{
    \v k_1, \dots, \v k_{i^* -1},
    \v q_1, \dots, \v q_{i^* -1},
    \v a_1, \dots, \v a_{i^* -1}
    \}$. One of the following is true:
        \begin{enumerate}
    \item $dir_\is = \For \quad$ and 
        $\quad
            \spn\big(\{ \v k_{i^*}, \v q_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F}_\is \cup \rows\left(\O\right) \big)
        $
    \item $dir_\is = \Back \quad$ and 
        $\quad
            \spn\big(\{ \v k_{i^*}, \v a_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F}_\is \cup \rows\left(\O\right) \big)
        $
\end{enumerate}
\item For all $j \geq i^*$ let $\mathcal{F}_j = \{
    \v k_1, \dots, \v k_{j -1},
    \v q_1, \dots, \v q_{j -1},
    \v a_1, \dots, \v a_{j -1}
    \}$. One of the following is true:
\begin{enumerate}
    \item $dir_j = \For \quad$ and 
        $\quad
        \v a_j \notin \spn\big(
        \mathcal{F}_j
        \cup \{ \v k_j, \v q_j\}
        \cup \rows\left(\O\right)
        \big)
        $
    \item $dir_j = \Back \quad$ and 
        $\quad
        \v q_j \notin \spn\big(
        \mathcal{F}_j
        \cup \{ \v k_j, \v a_j\}
        \cup \rows\left(\O\right)
        \big)
        $
\end{enumerate}
\end{enumerate}
\end{defn}

TODO: Remove this wordy definition.
All the info from here should be integrated into the example

\begin{defn}[Collision structure]
Let $\P = (\O, \C)$ be a Linicrypt program with $|\C| = n$.
A \textbf{collision structure} for $\P$ is an index $1 \leq i^* \leq n$, an ordering $(c_1, \dots, c_n)$ of $\C$ for $c_i = (Op_i, \v k_i, \v q_i,\v a_i)$
and a tuple $(dir_{i^*}, \dots, dir_n)$ for $dir_i \in \{\For, \Back\}$,
such that:
\begin{enumerate}
\item The $i^*$'th constraint is unconstrained by the output of $\P$ and previous fixed constraints.
Let $\mathcal{F} = \{
    \v k_1, \dots, \v k_{i^* -1},
    \v q_1, \dots, \v q_{i^* -1},
    \v a_1, \dots, \v a_{i^* -1}
    \}$
denote the vectors fixed by previous constraints in the ordering.
\begin{enumerate}
    \item if $dir_\is = \For$, the input of the query associated to $c_\is$ is unconstrained:
        \[
            \spn\big(\{ \v k_{i^*}, \v q_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F} \cup \rows\left(\O\right) \big)
        \]
    \item if $dir_\is = \Back$, the output of the query associated to $c_\is$ is unconstrained:
        \[
            \spn\big(\{ \v k_{i^*}, \v a_{i^*} \}\big) \nsubseteq
            \spn\big( \mathcal{F} \cup \rows\left(\O\right) \big)
        \]
\end{enumerate}
\item For all $j \geq i^*$ the constraint $c_j$ does not contradict previous constraints.
Let $\mathcal{F} = \{
    \v k_1, \dots, \v k_{j -1},
    \v q_1, \dots, \v q_{j -1},
    \v a_1, \dots, \v a_{j -1}
    \}$
denote the vectors fixed by previous constraints in the ordering.
\begin{enumerate}
    \item if $dir_j = \For$
        \[
        \v a_j \notin \spn\big( \{
        \v k_1, \dots, \v k_{j -1},
        \v q_1, \dots, \v q_{j -1},
        \v a_1, \dots, \v a_{j -1},
        \} 
        \cup \{ \v k_j, \v q_j\}
        \cup \rows\left(\O\right)
        \big)
        \]
    \item if $dir_j = \Back$
        \[
        \v q_j \notin \spn\big( \{
        \v k_1, \dots, \v k_{j -1},
        \v q_1, \dots, \v q_{j -1},
        \v a_1, \dots, \v a_{j -1},
        \} 
        \cup \{ \v k_j, \v a_j\}
        \cup \rows\left(\O\right)
        \big)
        \]
\end{enumerate}
\end{enumerate}
\end{defn}

\begin{lemma}[Collision structure gives second preimages]
    If collision structure blabla exists for $\P = (\O, \C)$ then blabla with probability 1.
\end{lemma}

\pcb[mode=text]{$\mathsf{FindSecondPreimage}\Big(\Big)$}{
Compute $\vbase$ by executing $\PE(\vx)$  \\
... very similar
}
